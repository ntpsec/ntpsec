#!/usr/bin/env python
#
# pyntpq - query an NTP server using mode 6 commands
#
# This is a direct translation of the ntpq C code, initially written to work as
# much like it as possible. Eventually it will replace the C version.
#
# Due to a limitation of the Python Cmd class, the ":config" and
# "config-from-file" commands lose their colons/hyphens.
#
# SPDX-License-Identifier: BSD-2-clause
from __future__ import print_function, division

import os, sys, getopt, cmd, errno, curses, curses.ascii
import socket, select, struct, shlex

from ntp.packet import *

# This import only works on Unixes.  The intention is to enable
# Ctrl-P, Ctrl-N, and friends in Cmd.
try:
    import readline
except ImportError:
    pass

version = "ntpq-py v1"

# General notes on Python 2/3 compatibility:
#
# This code uses the following strategy to allow it to run on both Python 2
# and Python 3:
#
# - Use binary I/O to read/write data from/to files and subprocesses;
#   where the exact bytes are important (such as in checking for
#   modified files), use the binary data directly
#
# - Use latin-1 encoding to transform binary data to/from Unicode when
#   necessary for operations where Python 3 expects Unicode; the
#   polystr and polybytes functions are used to do this so that
#   when running on Python 2, the byte string data is used unchanged;
#   also, the make_wrapper function constructs a text stream that can
#   wrap a file opened in binary mode for cases where a file object
#   that can be passed around from function to function is needed
#
# - Construct custom stdin, stdout, and stderr streams when running
#   on Python 3 that force latin-1 encoding, and wrap them around the
#   underlying binary buffers (in Python 2, the streams are binary
#   and are used unchanged); this ensures that the same transformation
#   is done on data from/to the standard streams, as is done on binary
#   data from/to files and subprocesses; the make_std_wrapper function
#   does this

master_encoding = 'latin-1'

if str is bytes:  # Python 2
    polystr = str
    polybytes = bytes

    def string_escape(s):
        return s.decode('string_escape')

    def make_wrapper(fp):
        return fp

else:  # Python 3
    import io

    def polystr(o):
        "Polymorphic string factory function"
        if isinstance(o, str):
            return o
        if not isinstance(o, bytes):
            return str(o)
        return str(o, encoding=master_encoding)

    def polybytes(s):
        "Polymorphic string encoding function"
        if isinstance(s, bytes):
            return s
        if not isinstance(s, str):
            return bytes(s)
        return bytes(s, encoding=master_encoding)

    def string_escape(s):
        "Polymorphic string_escape/unicode_escape"
        # This hack is necessary because Unicode strings in Python 3 don't
        # have a decode method, so there's no simple way to ask it for the
        # equivalent of decode('string_escape') in Python 2. This function
        # assumes that it will be called with a Python 3 'str' instance
        return s.encode(master_encoding).decode('unicode_escape')

    def make_wrapper(fp):
        "Wrapper factory function to enforce master encoding"
        # This can be used to wrap normally binary streams for API
        # compatibility with functions that need a text stream in
        # Python 3; it ensures that the binary bytes are decoded using
        # the master encoding we use to turn bytes to Unicode in
        # polystr above
        # newline="\n" ensures that Python 3 won't mangle line breaks
        return io.TextIOWrapper(fp, encoding=master_encoding, newline="\n")

    def make_std_wrapper(stream):
        "Standard input/output wrapper factory function"
        # This ensures that the encoding of standard output and standard
        # error on Python 3 matches the master encoding we use to turn
        # bytes to Unicode in polystr above
        # line_buffering=True ensures that interactive command sessions work as expected
        return io.TextIOWrapper(stream.buffer, encoding=master_encoding, newline="\n", line_buffering=True)

    sys.stdin = make_std_wrapper(sys.stdin)
    sys.stdout = make_std_wrapper(sys.stdout)
    sys.stderr = make_std_wrapper(sys.stderr)

# NTP-specific parts resume here

# Flags for forming descriptors.
OPT		= 0x80	# this argument is optional, or'd with type */
NO		= 0x0
NTP_STR		= 0x1	# string argument
NTP_UINT	= 0x2	# unsigned integer
NTP_INT		= 0x3	# signed integer
NTP_ADD		= 0x4	# IP network address
IP_VERSION	= 0x5	# IP version
NTP_ADP		= 0x6	# IP address and port
NTP_LFP		= 0x7	# NTP timestamp
NTP_MODE	= 0x8	# peer mode
NTP_2BIT	= 0x9	# leap bits

# Format values
PADDING	= 0
HA	= 1	# host address
NA	= 2	# network address
LP	= 3	# leap (print in binary)
RF	= 4	# refid (sometimes string, sometimes not)
AR	= 5	# array of times
FX	= 6	# test flags
TS	= 7	# l_fp timestamp in hex
OC	= 8	# integer, print in octal
EOV	= 255	# end of table

# For the most part ntpq simply displays what ntpd provides in the
# mostly plain-text mode 6 responses.  A few variable names are by
# default "cooked" to provide more human-friendly output.  This is
# a dictionary of cooked variables.
cookedvars = {
    "leap":		LP,
    "reach":		OC,
    "refid":		RF,
    "reftime":		TS,
    "clock":		TS,
    "org":		TS,
    "rec":		TS,
    "xmt":		TS,
    "flash":		FX,
    "srcadr":		HA,
    "peeradr":		HA,	# compat with others
    "dstadr":		NA,
    "filtdelay":	AR,
    "filtoffset":	AR,
    "filtdisp":		AR,
    "filterror":	AR,	# compat with others
}

uservars = {
}

# flasher bits
tstflagnames = (
	"pkt_dup",		# BOGON1
	"pkt_bogus",		# BOGON2
	"pkt_unsync",		# BOGON3
	"pkt_denied",		# BOGON4
	"pkt_auth",		# BOGON5
	"pkt_stratum",		# BOGON6
	"pkt_header",		# BOGON7
	"pkt_autokey",		# BOGON8
	"pkt_crypto",		# BOGON9
	"peer_stratum",		# BOGON10
	"peer_dist",		# BOGON11
	"peer_loop",		# BOGON12
	"peer_unreach"		# BOGON13
)

def collect_display(associd, variables, decodestatus):
    "Query and display a collection of variables from the system."
    pass

class ntpq_interpreter(cmd.Cmd):
    "ntpq command interpreter"

    def __init__(self, session):
        cmd.Cmd.__init__(self)
        self.session = session
        self.prompt = "pyntpq> "
        self.interactive       = False	# set to True when we should prompt
        self.old_rv            = False	# use old readvars behavior?
        #self.auth_keyid   = 0		# Keyid used for authentication.
        #self.auth_keytype = "NID_md5"	# MD5 (FIXME: string value is a dummy)
        #self.auth_hashlen = 16		# MD5
        self.rawmode           = False	# Flag which indicates raw mode output.
        self.showhostnames     = True	# If false, display numeric IPs
        #self.l_fp delay_time		# delay time
        self.wideremote = False		# show wide remote names?
        self.ccmds = []			# Queued commands
        self.chosts = []		# Command-line hosts
        self.debug = 0
        self.pktversion = NTP_VERSION

    def emptyline(self):
        "Called when an empty line is entered in response to the prompt."
        pass

    def help_help(self):
        sys.stdout.write("""\
function: tell the use and syntax of commands
usage: help [ command ]
""")

    def do_EOF(self, _unused):
        "exit ntpq"
        sys.stdout.write("\n")
        self.session.close()
        raise SystemExit(0)

    def do_timeout(self, line):
        "set the primary receive time out"
        if line:
            try:
                self.session.primary_timeout = int(line)
            except ValueError:
                print("What?")
        print("primary timeout %d ms" % self.session.primary_timeout)

    def help_timeout(self):
        sys.stdout.write("""\
function: set the primary receive time out
usage: timeout [ msec ]
""")

    def do_delay(self, line):
        "set the delay added to encryption time stamps"
        sys.stderr.write("Authentication is not yet implemented")

    def help_delay(self):
        sys.stdout.write("""\
function: set the delay added to encryption time stamps
usage: delay [ msec ]
""")

    def do_host(self, line):
        "specify the host whose NTP server we talk to"
        if not line:
            if self.session.havehost():
                print("current host is %s" % self.session.name)
            else:
                print("no current host")
        else:
            tokens = line.split()
            if tokens[0] == '-4':
                session.ai_family = socket.AF_INET
                tokens.pop(0)
            elif tokens[0] == '-6':
                session.ai_family = socket.AF_INET6
                tokens.pop(0)
            if tokens and self.session.openhost(tokens[0],session.ai_family):
                print("current host set to %s" % self.session.name)
            elif self.session.havehost():
                print("current host remains %s" % self.session.name)
            else:
                print("still no current host")

    def help_host(self):
        sys.stdout.write("""\
function: specify the host whose NTP server we talk to
usage: host [ -4|-6 ] [ hostname ]
""")

    def do_poll(self, line):
        "poll an NTP server in client mode `n' times"
        print("poll not implemented yet")

    def help_poll(self):
        sys.stdout.write("""\
function: poll an NTP server in client mode `n' times
usage: poll [ n ] [ verbose ]
""")

    def do_passwd(self, line):
        "specify a password to use for authenticated requests"
        sys.stderr.write("Authentication is not yet implemented")

    def help_passwd(self):
        sys.stdout.write("""\
function: specify a password to use for authenticated requests
usage: passwd [  ]
""")

    def do_hostnames(self, line):
        "specify whether hostnames or net numbers are printed"
        if not line:
            pass
        elif line == "yes":
            self.showhostnames = True
        elif line == "no":
            self.showhostnames = False
        else:
            print("What?")
        if self.showhostnames:
            print("hostnames being shown")
        else:
            print("hostnames not being shown")

    def help_hostnames(self):
        sys.stdout.write("""\
function: specify whether hostnames or net numbers are printed
usage: hostnames [ yes|no ]
""")

    def do_debug(self, line):
        "set/change debugging level"
        if not line:
            pass
        elif line == "more":
            self.debug +=1
        elif line == "less":
            self.debug -= 1
        elif line == "no":
            self.debug = 0
        else:
            try:
                self.debug = int(line)	# C version didn't implement this
            except ValueError:
                print("What?")
        self.session.debug = self.debug
        print("debug level is %d" % self.debug)

    def help_debug(self):
        sys.stdout.write("""\
function: set/change debugging level
usage: debug [ no|more|less ]
""")

    def do_exit(self, line):
        "exit ntpq"
        self.session.close()
        raise SystemExit(0)

    def help_exit(self):
        sys.stdout.write("""\
function: exit ntpq
usage: exit
""")
    do_quit = do_exit

    def help_quit(self):
        sys.stdout.write("""\
function: exit ntpq
usage: quit
""")

    def do_keyid(self, line):
        "set keyid to use for authenticated requests"
        if line:
            try:
                self.session.keyid = int(line)
            except ValueError:
                print("What?")
        if self.session.keyid is None:
            print("no keyid defined")
        else:
            print("keyid is %d" % self.session.keyid)

    def help_keyid(self):
        sys.stdout.write("""\
function: set keyid to use for authenticated requests
usage: keyid [ key# ]
""")

    def do_version(self, line):
        "print version number"
        print(version)

    def help_version(self):
        sys.stdout.write("""\
function: print version number
usage: version
""")

    def do_raw(self, line):
        "do raw mode variable output"
        self.rawmode = True
        print("Output set to raw")

    def help_raw(self):
        sys.stdout.write("""\
function: do raw mode variable output
usage: raw
""")

    def do_cooked(self, line):
        "do cooked mode variable output"
        self.rawmode = False
        print("Output set to cooked")

    def help_cooked(self):
        sys.stdout.write("""\
function: do cooked mode variable output
usage: cooked
""")

    def do_authenticate(self, line):
        "always authenticate requests to this server"
        if not line:
            pass
        elif line == "yes":
            self.session.always_auth = True
        elif line == "no":
            self.session.always_auth = False
        else:
            print("What?")
        if self.session.always_auth:
            print("authenticated requests being sent")
        else:
            print("unauthenticated requests being sent")

    def help_authenticate(self):
        sys.stdout.write("""\
function: always authenticate requests to this server
usage: authenticate [ yes|no ]
""")

    def do_ntpversion(self, line):
        "set the NTP version number to use for requests"
        if not line:
            pass
        else:
            try:
                newversion = int(line)
                if newversion >= NTP_OLDVERSION and newversion <= NTP_VERSION:
                    self.pktversion = newversion
                else:
                    print("versions %d to %d, please"
                          % (NTP_OLDVERSION, NTP_VERSION))
            except ValueError:
                print("What?")
        print("NTP version being claimed is %d" % self.pktversion)

    def help_ntpversion(self):
        sys.stdout.write("""\
function: set the NTP version number to use for requests
usage: ntpversion [ version number ]
""")

    def do_keytype(self, line):
        "set key type to use for authenticated requests"
        sys.stderr.write("Authentication is not yet implemented")
        pass

    def help_keytype(self):
        sys.stdout.write("""\
function: set key type to use for authenticated requests, one of:
    DSA, DSA-SHA, MD4, MD5, MDC2, RIPEMD160, SHA, SHA1
usage: keytype [ digest-name ]
""")

    def do_exercise(self, line):
        "Exercise the protocol - low level"
        tokens = shlex.split(line)
        if len(tokens) == 0:
            print("Requires an opcode, followed by optional associd and payload string")
            return
        elif len(tokens) == 1:
            tokens.append(0)
            tokens.append("")
        elif len(tokens) == 2:
            tokens.append("")
        msg = self.session.doquery(int(tokens[0]),
                                   int(tokens[1]),
                                   polybytes(tokens[2]))
        if msg:
            print(msg)

    def do_associations(self, line):
        "print list of association IDs and statuses for the server's peers"
        pass

    def help_associations(self):
        sys.stdout.write("""\
function: print list of association ID's and statuses for the server's peers
usage: associations
""")

    def do_passociations(self, line):
        "print list of associations returned by last associations command"
        pass

    def help_passociations(self):
        sys.stdout.write("""\
function: print list of associations returned by last associations command
usage: passociations
""")

    def do_lassociations(self, line):
        "print list of associations including all client information"
        pass

    def help_lassociations(self):
        sys.stdout.write("""\
function: print list of associations including all client information
usage: lassociations
""")

    def do_lpassociations(self, line):
        "print last obtained list of associations, including client information"
        pass

    def help_lpassociations(self):
        sys.stdout.write("""\
function: print last obtained list of associations, including client information
usage: lpassociations
""")

    def do_addvars(self, line):
        "add variables to the variable list or change their values"
        if line == "":
            print("usage addvars name[=value][,...]")
            return

        vars_to_add = line.split(',')
        for add_var in vars_to_add:
            uservars[add_var.split("=")[0].strip()] = add_var.split("=")[1].strip()

    def help_addvars(self):
        sys.stdout.write("""\
function: add variables to the variable list or change their values
usage: addvars name[=value][,...]
""")

    def do_rmvars(self, line):
        "remove variables from the variable list"
        if line == "":
            print("usage rmvars name[,...]")
            return

        vars_to_rm = line.split(',')
        for rm_var in vars_to_rm:
            if rm_var not in uservars:
                print("%s is not in the variable list" % rm_var)
            else:
                del uservars[rm_var]

    def help_rmvars(self):
        sys.stdout.write("""\
function: remove variables from the variable list
usage: rmvars name[,...]
""")

    def do_clearvars(self, line):
        "remove all variables from the variable list"
        uservars.clear()

    def help_clearvars(self):
        sys.stdout.write("""\
function: remove all variables from the variable list
usage: clearvars
""")

    def do_showvars(self, line):
        "print variables on the variable list"
        if len(uservars) == 0:
            print("No variables on list.")
        for name in uservars:
            print("%s=%s" % (name, uservars[name]))

    def help_showvars(self):
        sys.stdout.write("""\
function: print variables on the variable list
usage: showvars
""")

    def do_readlist(self, line):
        "read the system or peer variables included in the variable list"
        pass

    def help_readlist(self):
        sys.stdout.write("""\
function: read the system or peer variables included in the variable list
usage: readlist [ assocID ]
""")

    def do_rl(self, line):
        "read the system or peer variables included in the variable list"
        pass

    def help_rl(self):
        sys.stdout.write("""\
function: read the system or peer variables included in the variable list
usage: rl [ assocID ]
""")

    def do_writelist(self, line):
        "write the system or peer variables included in the variable list"
        pass

    def help_writelist(self):
        sys.stdout.write("""\
function: write the system or peer variables included in the variable list
usage: writelist [ assocID ]
""")

    def do_readvar(self, line):
        "read system or peer variables"
        pass

    def help_readvar(self):
        sys.stdout.write("""\
function: read system or peer variables
usage: readvar [ assocID ] [ varname1 ] [ varname2 ] [ varname3 ]
""")

    def do_rv(self, line):
        "read system or peer variables"
        pass

    def help_rv(self):
        sys.stdout.write("""\
function: read system or peer variables
usage: rv [ assocID ] [ varname1 ] [ varname2 ] [ varname3 ]
""")

    def do_writevar(self, line):
        "write system or peer variables"
        pass

    def help_writevar(self):
        sys.stdout.write("""\
function: write system or peer variables
usage: writevar assocID name=value,[...]
""")

    def do_mreadlist(self, line):
        "read the peer variables in the variable list for multiple peers"
        pass

    def help_mreadlist(self):
        sys.stdout.write("""\
function: read the peer variables in the variable list for multiple peers
usage: mreadlist assocIDlow assocIDhigh
""")

    def do_mrl(self, line):
        "read the peer variables in the variable list for multiple peers"
        pass

    def help_mrl(self):
        sys.stdout.write("""\
function: read the peer variables in the variable list for multiple peers
usage: mrl assocIDlow assocIDhigh
""")

    def do_mreadvar(self, line):
        "read peer variables from multiple peers"
        pass

    def help_mreadvar(self):
        sys.stdout.write("""\
function: read peer variables from multiple peers
usage: mreadvar assocIDlow assocIDhigh [ name=value[,...] ]
""")

    def do_mrv(self, line):
        "read peer variables from multiple peers"
        pass

    def help_mrv(self):
        sys.stdout.write("""\
function: read peer variables from multiple peers
usage: mrv assocIDlow assocIDhigh [ name=value[,...] ]
""")

    def do_clocklist(self, line):
        "read the clock variables included in the variable list"
        pass

    def help_clocklist(self):
        sys.stdout.write("""\
function: read the clock variables included in the variable list
usage: clocklist [ assocID ]
""")

    def do_cl(self, line):
        "read the clock variables included in the variable list"
        pass

    def help_cl(self):
        sys.stdout.write("""\
function: read the clock variables included in the variable list
usage: cl [ assocID ]
""")

    def do_clockvar(self, line):
        "read clock variables"
        pass

    def help_clockvar(self):
        sys.stdout.write("""\
function: read clock variables
usage: clockvar [ assocID ] [ name=value[,...] ]
""")

    def do_cv(self, line):
        "read clock variables"
        pass

    def help_cv(self):
        sys.stdout.write("""\
function: read clock variables
usage: cv [ assocID ] [ name=value[,...] ]
""")

    def do_pstats(self, line):
        "show statistics for a peer"
        pstats = (
            ("src",		"remote host:         ", NTP_ADD),
            ("dst",		"local address:       ", NTP_ADD),
            ("timerec",		"time last received:  ", NTP_STR),
            ("timer",		"time until next send:", NTP_STR),
            ("timereach",	"reachability change: ", NTP_STR),
            ("sent",		"packets sent:        ", NTP_STR),
            ("received",	"packets received:    ", NTP_STR),
            ("badauth",		"bad authentication:  ", NTP_STR),
            ("bogusorg",	"bogus origin:        ", NTP_STR),
            ("oldpkt",		"duplicate:           ", NTP_STR),
            ("seldisp",		"bad dispersion:      ", NTP_STR),
            ("selbroken",	"bad reference time:  ", NTP_STR),
            ("candidate",	"candidate order:     ", NTP_STR),
        )
        associd=int(line)
        # FIXME: validate the association ID.
	collect_display_vdc(associd=associd,variables=pstats,decodestatus=True);

    def help_pstats(self):
        sys.stdout.write("""\
function: show statistics for a peer
usage: pstats assocID
""")

    def do_peers(self, line):
        "obtain and print a list of the server's peers [IP version]"
        pass

    def help_peers(self):
        sys.stdout.write("""\
function: obtain and print a list of the server's peers [IP version]
usage: peers [ -4|-6 ]
""")

    def do_apeers(self, line):
        "obtain and print a list of the server's peers and their assocIDs [IP version]"
        pass

    def help_apeers(self):
        sys.stdout.write("""\
function: obtain and print a list of the server's peers and their assocIDs [IP version]
usage: apeers [ -4|-6 ]
""")

    def do_lpeers(self, line):
        "obtain and print a list of all peers and clients [IP version]"
        pass

    def help_lpeers(self):
        sys.stdout.write("""\
function: obtain and print a list of all peers and clients [IP version]
usage: lpeers [ -4|-6 ]
""")

    def do_opeers(self, line):
        "print peer list the old way, with dstadr shown rather than refid [IP version]"
        pass

    def help_opeers(self):
        sys.stdout.write("""\
function: print peer list the old way, with dstadr shown rather than refid [IP version]
usage: opeers [ -4|-6 ]
""")

    def do_lopeers(self, line):
        "obtain and print a list of all peers and clients showing dstadr [IP version]"
        pass

    def help_lopeers(self):
        sys.stdout.write("""\
function: obtain and print a list of all peers and clients showing dstadr [IP version]
usage: lopeers [ -4|-6 ]
""")

    def do_config(self, line):
        "send a remote configuration command to ntpd"
        pass

    def help_config(self):
        sys.stdout.write("""\
function: send a remote configuration command to ntpd
usage: config <configuration command line>
""")

    def do_config_from_file(self, line):
        "configure ntpd using the configuration filename"
        pass

    def help_config_from_file(self):
        sys.stdout.write("""\
function: configure ntpd using the configuration filename
usage: config_from_file <configuration filename>
""")

    def do_mrulist(self, line):
        "display the list of most recently seen source addresses, tags mincount=... resall=0x... resany=0x..."
        pass

    def help_mrulist(self):
        sys.stdout.write("""\
function: display the list of most recently seen source addresses, tags mincount=... resall=0x... resany=0x...
usage: mrulist [ tag=value ] [ tag=value ] [ tag=value ] [ tag=value ]
""")

    def do_ifstats(self, line):
        "show statistics for each local address ntpd is using"
        pass

    def help_ifstats(self):
        sys.stdout.write("""\
function: show statistics for each local address ntpd is using
usage: ifstats
""")

    def do_reslist(self, line):
        "show ntpd access control list"
        pass

    def help_reslist(self):
        sys.stdout.write("""\
function: show ntpd access control list
usage: reslist
""")

    def do_sysinfo(self, _line):
        "display system summary"
        sysinfo = (
            ("peeradr",		"system peer:      ", NTP_ADP),
            ("peermode",	"system peer mode: ", NTP_MODE),
            ("leap",		"leap indicator:   ", NTP_2BIT),
            ("stratum",		"stratum:          ", NTP_STR),
            ("precision",	"log2 precision:   ", NTP_STR),
            ("rootdelay",	"root delay:       ", NTP_STR),
            ("rootdisp",	"root dispersion:  ", NTP_STR),
            ("refid",		"reference ID:     ", NTP_STR),
            ("reftime",		"reference time:   ", NTP_LFP),
            ("sys_jitter",	"system jitter:    ", NTP_STR),
            ("clk_jitter",	"clock jitter:     ", NTP_STR),
            ("clk_wander",	"clock wander:     ", NTP_STR),
            ("bcastdelay",	"broadcast delay:  ", NTP_STR),
            ("authdelay",	"symm. auth. delay:", NTP_STR),
        )
        collect_display(associd=0, variables=sysinfo, decodestatus=True)

    def help_sysinfo(self):
        sys.stdout.write("""\
function: display system summary
usage: sysinfo
""")

    def do_kerninfo(self, _line):
        "display kernel loop and PPS statistics"
        kerninfo = (
            ("koffset",		"pll offset:          ", NTP_STR),
            ("kfreq",		"pll frequency:       ", NTP_STR),
            ("kmaxerr",		"maximum error:       ", NTP_STR),
            ("kesterr",		"estimated error:     ", NTP_STR),
            ("kstflags",	"kernel status:       ", NTP_STR),
            ("ktimeconst",	"pll time constant:   ", NTP_STR),
            ("kprecis",		"precision:           ", NTP_STR),
            ("kfreqtol",	"frequency tolerance: ", NTP_STR),
            ("kppsfreq",	"pps frequency:       ", NTP_STR),
            ("kppsstab",	"pps stability:       ", NTP_STR),
            ("kppsjitter",	"pps jitter:          ", NTP_STR),
            ("kppscalibdur",	"calibration interval ", NTP_STR),
            ("kppscalibs",	"calibration cycles:  ", NTP_STR),
            ("kppsjitexc",	"jitter exceeded:     ", NTP_STR),
            ("kppsstbexc",	"stability exceeded:  ", NTP_STR),
            ("kppscaliberrs",	"calibration errors:  ", NTP_STR),
        )
        collect_display(associd=0, variables=kerninfo, decodestatus=True)

    def help_kerninfo(self):
        sys.stdout.write("""\
function: display kernel loop and PPS statistics
usage: kerninfo
""")

    def do_sysstats(self, _line):
        "display system uptime and packet counts"
        sysstats = (
            ("ss_uptime",	"uptime:               ", NTP_STR),
            ("ss_reset",	"sysstats reset:       ", NTP_STR),
            ("ss_received",	"packets received:     ", NTP_STR),
            ("ss_thisver",	"current version:      ", NTP_STR),
            ("ss_oldver",	"older version:        ", NTP_STR),
            ("ss_badformat",	"bad length or format: ", NTP_STR),
            ("ss_badauth",	"authentication failed:", NTP_STR),
            ("ss_declined",	"declined:             ", NTP_STR),
            ("ss_restricted",	"restricted:           ", NTP_STR),
            ("ss_limited",	"rate limited:         ", NTP_STR),
            ("ss_kodsent",	"KoD responses:        ", NTP_STR),
            ("ss_processed",	"processed for time:   ", NTP_STR),
        )
        collect_display(associd=0, variables=sysstats, decodestatus=False)

    def help_sysstats(self):
        sys.stdout.write("""\
function: display system uptime and packet counts
usage: sysstats
""")

    def do_monstats(self, _line):
        "display monitor (mrulist) counters and limits"
        monstats = (
            ("mru_enabled",	"enabled:            ", NTP_STR),
            ("mru_depth",	"addresses:          ", NTP_STR),
            ("mru_deepest",	"peak addresses:     ", NTP_STR),
            ("mru_maxdepth",	"maximum addresses:  ", NTP_STR),
            ("mru_mindepth",	"reclaim above count:", NTP_STR),
            ("mru_maxage",	"reclaim older than: ", NTP_STR),
            ("mru_mem",		"kilobytes:          ", NTP_STR),
            ("mru_maxmem",	"maximum kilobytes:  ", NTP_STR),
        )
	collect_display(associd=0, variables=monstats, decodestatus=False)

    def help_monstats(self):
        sys.stdout.write("""\
function: display monitor (mrulist) counters and limits
usage: monstats
""")

    def do_authinfo(self, _line):
        "display symmetric authentication counters"
        authinfo = (
            ("authreset",	"time since reset:", NTP_STR),
            ("authkeys",	"stored keys:     ", NTP_STR),
            ("authfreek",	"free keys:       ", NTP_STR),
            ("authklookups",	"key lookups:     ", NTP_STR),
            ("authknotfound",	"keys not found:  ", NTP_STR),
            ("authkuncached",	"uncached keys:   ", NTP_STR),
            ("authkexpired",	"expired keys:    ", NTP_STR),
            ("authencrypts",	"encryptions:     ", NTP_STR),
            ("authdecrypts",	"decryptions:     ", NTP_STR),
        )
        collect_display(associd=0, variables=authinfo, decodestatus=False)

    def help_authinfo(self):
        sys.stdout.write("""\
function: display symmetric authentication counters
usage: authinfo
""")

    def do_iostats(self, _line):
        "display network input and output counters"
        iostats = (
            ("iostats_reset",	"time since reset:     ", NTP_STR),
            ("total_rbuf",	"receive buffers:      ", NTP_STR),
            ("free_rbuf",	"free receive buffers: ", NTP_STR),
            ("used_rbuf",	"used receive buffers: ", NTP_STR),
            ("rbuf_lowater",	"low water refills:    ", NTP_STR),
            ("io_dropped",	"dropped packets:      ", NTP_STR),
            ("io_ignored",	"ignored packets:      ", NTP_STR),
            ("io_received",	"received packets:     ", NTP_STR),
            ("io_sent",		"packets sent:         ", NTP_STR),
            ("io_sendfailed",	"packet send failures: ", NTP_STR),
            ("io_wakeups",	"input wakeups:        ", NTP_STR),
            ("io_goodwakeups",	"useful input wakeups: ", NTP_STR),
        )
	collect_display(associd=0, variables=iostats, decodestatus=False)

    def help_iostats(self):
        sys.stdout.write("""\
function: display network input and output counters
usage: iostats
""")

    def do_timerstats(self, line):
        "display interval timer counters"
        timerstats = (
            ("timerstats_reset",	"time since reset:  ", NTP_STR),
            ("timer_overruns",		"timer overruns:    ", NTP_STR),
            ("timer_xmts",		"calls to transmit: ", NTP_STR),
        )
        collect_display(associd=0, variables=timerstats, decodestatus=False)

    def help_timerstats(self):
        sys.stdout.write("""\
function: display interval timer counters
usage: timerstats
""")

# Default values we use.
DEFHOST 	= "localhost"	# default host name

# Requests are automatically retried once, so total timeout with no
# response is a bit over 2 * DEFTIMEOUT, or 10 seconds.  At the other
# extreme, a request eliciting 32 packets of responses each for some
# reason nearly DEFSTIMEOUT seconds after the prior in that series,
# with a single packet dropped, would take around 32 * DEFSTIMEOUT, or
# 93 seconds to fail each of two times, or 186 seconds.
# Some commands involve a series of requests, such as "peers" and
# "mrulist", so the cumulative timeouts are even longer for those.
DEFDELAY	= 0x51EB852	# 20 milliseconds, l_fp fraction
MAXVARLEN	= 256		# maximum length of a variable name
MAXVALLEN	= 2048		# maximum length of a variable value
MAXOUTLINE	= 72		# maximum length of an output line
SCREENWIDTH	= 76		# nominal screen width in columns

# Macro definitions we use
def ISSPACE(c):	return ((c) == ' ' or (c) == '\t')
def ISEOL(c):	return ((c) == '\n' or (c) == '\r' or (c) == '\0')

#
# main - parse arguments and handle options
#

usage = '''
USAGE: ntpq [-46dphinOV] [-c str] [-D lvl] [ host ...]
  Flg Arg Option-Name    Description
   -4 no  ipv4           Force IPv4 DNS name resolution
				- prohibits the option 'ipv6'
   -6 no  ipv6           Force IPv6 DNS name resolution
				- prohibits the option 'ipv4'
   -c Str command        run a command and exit
				- may appear multiple times
   -d no  debug-level    Increase output debug message level
				- may appear multiple times
   -D Str set-debug-level Set the output debug message level
				- may appear multiple times
   -h no  help           Print a usage message.
   -p no  peers          Print a list of the peers
				- prohibits the option 'interactive'
   -i no  interactive    Force ntpq to operate in interactive mode
				- prohibits these options:
				command
				peers
   -n no  numeric        numeric host addresses
   -O no  old-rv         Always output status line with readvar
   -V opt version        Output version information and exit
   -w no  wide           enable wide display of addresses
'''

if __name__ == '__main__':
    #delay_time.l_ui = 0
    #delay_time.l_uf = DEFDELAY

    #init_lib()	# sets up ipv4_works, ipv6_works
    #init_auth()

    try:
        (options, arguments) = getopt.getopt(sys.argv[1:],
                                             "46c:dD:hinOpVw",
                                             ["ipv4","ipv6","command",
                                              "debug","set-debug-level",
                                              "help", "interactive", "numeric",
                                              "old-rv","peers","version",
                                              "wide"])
    except getopt.GetoptError as e:
        print(e)
        raise SystemExit(1)
    progname = sys.argv[0]

    session = ntpq_session()
    interpreter = ntpq_interpreter(session)

    for (switch, val) in options:
        if switch in ("-4", "--ipv4"):
            interpreter.ai_family = socket.AF_INET
        elif switch in ("-6", "--ipv6"):
            interpreter.ai_family = socket.AF_INET6
        elif switch in ("-c", "--command"):
            interpreter.ccmds.append(val)
        elif switch in ("-d", "--debug"):
            interpreter.debug += 1
        elif switch in ("-D", "--set-debug-level"):
            interpreter.debug = int(val)
        elif switch in ("-h", "--help"):
            print(usage)
            raise SystemExit(0)
        elif switch in ("-i", "--interactive"):
            interpreter.interactive = True
        elif switch in ("-n", "--numeric"):
            interpreter.showhostnames = False
        elif switch in ("-O", "--old-rv"):
            interpreter.old_rv = True
        elif switch in ("-p", "--peers"):
            interpreter.ccmds.append("peers")
        elif switch in ("-V", "--version"):
            print("ntpq %s\n" % version)
            raise SystemExit(0)
        elif switch in ("-w", "--wide"):
            interpreter.wideremote = True
        else:
            sys.stderr.write("Unknown command line switch or missing argument.\n")
            sys.stderr.write(usage)
            raise SystemExit(1)

    if interpreter.interactive and len(interpreter.ccmds) > 0:
        sys.stderr.write("%s: invalid option combination.\n" % progname)
        raise SystemExit(1)

    if len(arguments) == 0:
        interpreter.chosts.append((DEFHOST, session.ai_family))
    else:
        for token in arguments:
            if token.startswith("-"):
                if '4' == token[1]:
                    session.ai_family = socket.AF_INET
                elif '6' == token[1]:
                    session.ai_family = socket.AF_INET6
            else:
                interpreter.chosts.append((token, session.ai_family))

    if len(interpreter.ccmds) == 0 and not interpreter.interactive and os.isatty(0) and os.isatty(1):
        interpreter.interactive = True

    try:
        if len(interpreter.ccmds) == 0:
            session.openhost(*interpreter.chosts[0])
            interpreter.cmdloop()
        else:
            for ihost in interpreter.chosts:
                if session.openhost(*ihost):
                    for cmd in interpreter.ccmds:
                        interpreter.onecmd(cmd)
                    session.close()
        raise SystemExit(0)
    except KeyboardInterrupt:
        sys.stdout.write("\n")
# end
