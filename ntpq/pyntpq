#!/usr/bin/env python
#
# pyntpq - query an NTP server using mode 6 commands
#
# This is a direct translation of the ntpq C code, initially written to work as
# much like it as possible. Eventually it will replace the C version.
#
# Due to a limitation of the Python Cmd class, the ":config" and
# "config-from-file" commands lose their colons/hyphens.
#
# SPDX-License-Identifier: BSD-2-clause
from __future__ import print_function, division

import os, sys, getopt, cmd, errno, curses, curses.ascii
import socket, select, struct, shlex, time

from ntp.packet import *
from ntp.util import *
from ntp.ntpc import *

# This import only works on Unixes.  The intention is to enable
# Ctrl-P, Ctrl-N, and friends in Cmd.
try:
    import readline
except ImportError:
    pass

version = "ntpq-py v1"

# General notes on Python 2/3 compatibility:
#
# This code uses the following strategy to allow it to run on both Python 2
# and Python 3:
#
# - Use binary I/O to read/write data from/to files and subprocesses;
#   where the exact bytes are important (such as in checking for
#   modified files), use the binary data directly
#
# - Use latin-1 encoding to transform binary data to/from Unicode when
#   necessary for operations where Python 3 expects Unicode; the
#   polystr and polybytes functions are used to do this so that
#   when running on Python 2, the byte string data is used unchanged;
#   also, the make_wrapper function constructs a text stream that can
#   wrap a file opened in binary mode for cases where a file object
#   that can be passed around from function to function is needed
#
# - Construct custom stdin, stdout, and stderr streams when running
#   on Python 3 that force latin-1 encoding, and wrap them around the
#   underlying binary buffers (in Python 2, the streams are binary
#   and are used unchanged); this ensures that the same transformation
#   is done on data from/to the standard streams, as is done on binary
#   data from/to files and subprocesses; the make_std_wrapper function
#   does this

master_encoding = 'latin-1'

if str is bytes:  # Python 2
    polystr = str
    polybytes = bytes

    def string_escape(s):
        return s.decode('string_escape')

    def make_wrapper(fp):
        return fp

else:  # Python 3
    import io

    def polystr(o):
        "Polymorphic string factory function"
        if isinstance(o, str):
            return o
        if not isinstance(o, bytes):
            return str(o)
        return str(o, encoding=master_encoding)

    def polybytes(s):
        "Polymorphic string encoding function"
        if isinstance(s, bytes):
            return s
        if not isinstance(s, str):
            return bytes(s)
        return bytes(s, encoding=master_encoding)

    def string_escape(s):
        "Polymorphic string_escape/unicode_escape"
        # This hack is necessary because Unicode strings in Python 3 don't
        # have a decode method, so there's no simple way to ask it for the
        # equivalent of decode('string_escape') in Python 2. This function
        # assumes that it will be called with a Python 3 'str' instance
        return s.encode(master_encoding).decode('unicode_escape')

    def make_wrapper(fp):
        "Wrapper factory function to enforce master encoding"
        # This can be used to wrap normally binary streams for API
        # compatibility with functions that need a text stream in
        # Python 3; it ensures that the binary bytes are decoded using
        # the master encoding we use to turn bytes to Unicode in
        # polystr above
        # newline="\n" ensures that Python 3 won't mangle line breaks
        return io.TextIOWrapper(fp, encoding=master_encoding, newline="\n")

    def make_std_wrapper(stream):
        "Standard input/output wrapper factory function"
        # This ensures that the encoding of standard output and standard
        # error on Python 3 matches the master encoding we use to turn
        # bytes to Unicode in polystr above
        # line_buffering=True ensures that interactive command sessions work as expected
        return io.TextIOWrapper(stream.buffer, encoding=master_encoding, newline="\n", line_buffering=True)

    sys.stdin = make_std_wrapper(sys.stdin)
    sys.stdout = make_std_wrapper(sys.stdout)
    sys.stderr = make_std_wrapper(sys.stderr)

# NTP-specific parts resume here

# Flags for forming descriptors.
OPT		= 0x80	# this argument is optional, or'd with type */
NO		= 0x0
NTP_STR		= 0x1	# string argument
NTP_UINT	= 0x2	# unsigned integer
NTP_INT		= 0x3	# signed integer
NTP_ADD		= 0x4	# IP network address
IP_VERSION	= 0x5	# IP version
NTP_ADP		= 0x6	# IP address and port
NTP_LFP		= 0x7	# NTP timestamp
NTP_MODE	= 0x8	# peer mode
NTP_2BIT	= 0x9	# leap bits

class Ntpq(cmd.Cmd):
    "ntpq command interpreter"

    def __init__(self, session):
        cmd.Cmd.__init__(self)
        self.session = session
        self.prompt = "pyntpq> "
        self.interactive       = False	# set to True when we should prompt
        self.old_rv            = False	# use old readvars behavior?
        #self.auth_keyid   = 0		# Keyid used for authentication.
        #self.auth_keytype = "NID_md5"	# MD5 (FIXME: string value is a dummy)
        #self.auth_hashlen = 16		# MD5
        self.rawmode           = False	# Flag which indicates raw mode output.
        self.showhostnames     = True	# If false, display numeric IPs
        self.auth_delay    = 20		# delay time (default 20msec)
        self.wideremote = False		# show wide remote names?
        self.ccmds = []			# Queued commands
        self.chosts = []		# Command-line hosts
        self.peers = []			# Data from NTP peers.
        self.debug = 0
        self.pktversion = NTP_OLDVERSION + 1
        self.uservars = collections.OrderedDict()
        # By default, the peer spreadsheet layout is designed so lines just
        # fit in 80 characters. This tells us how much extra horizontal space
        # we have available on a wider terminal emulator
        self.horizontal_slack = termsize()[1] - 80
        # Peer spreadsheet column widths
        self.namewidth = 15 + self.horizontal_slack
        self.refidwidth = 15
        # Compute peer spreadsheet headers 
        self.__remote = "     remote    ".ljust(self.namewidth)
        self.__common = "st t when poll reach   delay   offset  "
        self.__opeerheader = self.__remote + \
                             "       local      ".ljust(self.refidwidth) + \
                             self.__common + "  disp\n"
        self.__peerheader  = self.__remote + \
                             "       refid      ".ljust(self.refidwidth) + \
                             self.__common + "jitter\n"
        self.__apeerheader = self.__remote + \
                             "   refid   assid  ".ljust(self.refidwidth) + \
                             self.__common + "jitter\n"

    def emptyline(self):
        "Called when an empty line is entered in response to the prompt."
        pass

    def say(self, msg):
        sys.stdout.write(msg)

    def warn(self, msg):
        sys.stderr.write(msg)

    def help_help(self):
        self.say("""\
function: tell the use and syntax of commands
usage: help [ command ]
""")

    # Unexposed helper tables and functions begin here

    @staticmethod
    def high_truncate(hostname, maxlen):
        "Truncate on the left using leading _ to indicate 'more'."
        # Used for local IPv6 addresses, best distinguished by low bits
        if len(hostname) <= maxlen:
            return hostname
        else:
            return '-' + hostname[-maxlen+1:]

    def __dogetassoc(self):
        try:
            self.peers = self.session.readstat()
        except Mode6Exception as e:
            print(e.message)
            return False

        if len(self.peers) == 0:
            if self.chosts:
                self.say("server=%s ", self.session.hostname)
            self.say("No association IDs returned\n")
            return False

        if self.debug:
            self.warn("\n%d associations total\n" % len(self.peers))
        #sortassoc()
        return True

    def __printassoc(self, showall):
        condition = "";
        if not self.peers:
            self.say("No association IDs in list\n");
            return;
        self.say("\nind assid status  conf reach auth condition  last_event cnt\n");
        self.say("===========================================================\n");
        for (i, peer) in enumerate(self.peers):
            statval = CTL_PEER_STATVAL(peer.status)
            if not showall and (statval & (CTL_PST_CONFIG|CTL_PST_REACH)) == 0:
                continue
            event = CTL_PEER_EVENT(peer.status)
            event_count = CTL_PEER_NEVNT(peer.status)
            if statval & CTL_PST_CONFIG:
                conf = "yes"
            else:
                conf = "no"
            if statval & CTL_PST_BCAST:
                    reach = "none"
                    if statval & CTL_PST_AUTHENABLE:
                            auth = "yes"
                    else:
                            auth = "none"
            elif statval & CTL_PST_REACH:
                reach = "yes"
            else:
                reach = "no"
            if (statval & CTL_PST_AUTHENABLE) == 0:
                auth = "none"
            elif statval & CTL_PST_AUTHENTIC:
                auth = "ok "
            else:
                auth = "bad"
            if self.pktversion > NTP_OLDVERSION:
                seldict = {
                    CTL_PST_SEL_REJECT: "reject",
                    CTL_PST_SEL_SANE: "falsetick",
                    CTL_PST_SEL_CORRECT: "excess",
                    CTL_PST_SEL_SELCAND: "outlier",
                    CTL_PST_SEL_SYNCCAND: "candidate",
                    CTL_PST_SEL_EXCESS: "backup",
                    CTL_PST_SEL_SYSPEER: "sys.peer",
                    CTL_PST_SEL_PPS: "pps.peer",
                    }
                condition = seldict[statval & 0x7]
            else:
                if (statval & 0x3) == OLD_CTL_PST_SEL_REJECT:
                    if (statval & OLD_CTL_PST_SANE) == 0:
                        condition = "insane"
                    elif (statval & OLD_CTL_PST_DISP) == 0:
                        condition = "hi_disp"
                    else:
                        condition = ""
                elif (statval & 0x3) ==  OLD_CTL_PST_SEL_SELCAND:
                        condition = "sel_cand"
                elif (statval & 0x3) ==  OLD_CTL_PST_SEL_SYNCCAND:
                    condition = "sync_cand"
                elif (statval & 0x3) ==  OLD_CTL_PST_SEL_SYSPEER:
                    condition = "sys_peer"
            event_dict = {
                PEVNT_MOBIL: "mobilize",
                PEVNT_DEMOBIL: "demobilize",
                PEVNT_REACH: "reachable",
                PEVNT_UNREACH: "unreachable",
                PEVNT_RESTART: "restart",
                PEVNT_REPLY: "no_reply",
                PEVNT_RATE: "rate_exceeded",
                PEVNT_DENY: "access_denied",
                PEVNT_ARMED: "leap_armed",
                PEVNT_NEWPEER: "sys_peer",
                PEVNT_CLOCK: "clock_alarm",
                }
            last_event = event_dict.get(PEER_EVENT|event, "")
            display = \
                     "%3d %5u  %04x   %3.3s  %4s  %4.4s %9.9s %11s %2lu" % \
                     (i + 1, peer.associd,
                     peer.status, conf, reach, auth,
                     condition, last_event, event_count)
            self.say(display + "\n")

    @staticmethod
    def prettyinterval(diff):
        "Print an interval in natural time units."
        if diff <= 0:
            return "-"
        if diff <= 2048:
            return str(diff)
        diff = (diff + 29) / 60
        if diff <= 300:
            return "%dm" % diff
        diff = (diff + 29) / 60
        if diff <= 96:
            return "%dh" % diff
        diff = (diff + 11) / 24
        return "%dd" % diff

    def __doprintpeers(self, variables, header, associd):
        hmode = 0
        srchost = None
        srcport = 0
        srcaddr = None
        dstadr_refid = ""
        ppoll = 0
        hpoll = 0
        reach = 0
        ptype = '?'
        displayname = None
        have_jitter = False
        clock_name = ''

        now = time.time()

        for (name, value) in variables.items():
            if name in ("srcadr", "peeradr"):
                srcaddr = value
            elif name == "srchost":
                srchost = value
            elif name == "dstadr":
                # The C code tried to get a fallback pytpe from this in case
                # the hmode field was not included
                if "local" in header:
                    dstadr_refid = value
            elif name == "hmode":
                hmode = value
            elif name == "refid":
                # The C code for this looked crazily overelaborate.  Best
                # guess is that it was designed to deal with formats that
                # no longer occur in this field.
                if "refid" in header:
                    dstadr_refid = value
            elif name == "hpoll":
                hpoll = value
                if hpoll < 0:
                    hpoll = NTP_MINPOLL
            elif name == "ppoll":
                ppoll = value
                if ppoll < 0:
                    ppoll = NTP_MINPOLL
            elif name == "reach":
                # Shipped as hex, displayed in octal
                reach = value
            elif name == "delay":
                estdelay = value
            elif name == "offset":
                estoffset = value
            elif name == "jitter":
                if "jitter" in header:
                    estjitter = value
                    have_jitter = True
            elif name == "rootdisp" or name == "dispersion":
                estdisp = value
            elif name == "rec":
                rec = value	# l_fp timestamp
            elif name == "srcport" or name == "peerport":
                srcport = value
            elif name == "reftime":
                reftime = value	# l_fp timestamp
            elif name == "displayname":
                displayname = value
        if hmode == MODE_BCLIENT:
            # broadcastclient or multicastclient
            ptype = 'b'
        elif hmode == MODE_BROADCAST:
            # broadcast or multicast server
            if srcaddr.startswith("224."):	# IANA multicast address prefix
                ptype = 'M'
            else:
                ptype = 'B'
        elif hmode == MODE_CLIENT:
            if displayname != None:
                ptype = 'l'	# local refclock
            elif dstadr_refid == "POOL":
                ptype = 'p'	# pool
            elif srcaddr.startswith("224."):
                ptype = 'a'	# manycastclient
            else:
                ptype = 'u'	# unicast
        elif hmode == MODE_ACTIVE:
            ptype = 's'		# symmetric active
        elif hmode == MODE_PASSIVE:
            ptype = 'S'		# symmetric passive

        #
        # Got everything, format the line
        #
        poll_sec = 1 << min(ppoll, hpoll)
        if self.pktversion > NTP_OLDVERSION:
            c = " x.-+#*o"[CTL_PEER_STATVAL(self.session.rstatus) & 0x7]
        else:
            c = " .+*"[CTL_PEER_STATVAL(self.session.rstatus) & 0x3]
        if len(self.chosts) > 1:
            maxhostlen = max([len(host) for (host, _af) in self.chosts])
            self.say(Ntpq.high_truncate(self.session.hostname, maxhostlen)+ " ")
        # Source host or clockname
        if displayname != None and self.showhostnames:
            clock_name = displayname
        elif srchost != None:
            clock_name = srchost
        else:
            clock_name = canonicalize_dns(srcaddr)
        if interpreter.wideremote and len(clock_name) > self.namewidth:
            self.say("%c%s\n" % (c, clock_name))
            sys.stdout(" " * (self.namewidth + 2))
        else:
            self.say("%c%-*.*s " % \
                             (c, self.namewidth, self.namewidth, clock_name[:self.namewidth]))
        # Destination address, assoc ID or refid.
        assocwidth = 7 if "assid" in header else 0
        if "." not in dstadr_refid:
            dstadr_refid = "." + dstadr_refid + "."
        if assocwidth and len(dstadr_refid) >= self.refidwidth - assocwidth:
            visible = "..."
        else:
            visible = dstadr_refid
        self.say(visible)
        if "assid" in header:
            self.say(" " * (self.refidwidth - len(visible) - assocwidth + 1))
            self.say("%-6d" % (associd))
        else:
            self.say(" " * (self.refidwidth - len(visible)))
        # The rest of the story
        last_sync = variables.get("rec") or variables.get("reftime")
        jd = estjitter if have_jitter else estdisp
        jd = "      -" if jd >= 999 else ("%7.3f" % jd)
        self.say(
            " %2ld %c %4.4s %4.4s  %3lo  %7.3f %8.3f %s\n" % \
            (variables.get("stratum", 0),
             ptype,
             Ntpq.prettyinterval(now if last_sync is None else int(now - lfptofloat(last_sync))),
             Ntpq.prettyinterval(poll_sec),
             reach, estdelay, estoffset,
             jd))
        return True

    def __dogetpeers(self, header, associd):
        try:
            variables = self.session.readvar(associd)
        except Mode6Exception as e:
            print(e.message)
            return False
        if not variables:
            if len(self.chosts) > 1:
                self.warn("server=%s ", self.session.hostname)
            self.warn("***No information returned for association %d\n" \
                             % associd)
            return False;
        return self.__doprintpeers(variables, header, associd);

    def __dopeers(self, showall, header):
        if not self.__dogetassoc():
            return
        maxhostlen = 0
        if len(self.chosts) > 1:
            maxhostlen = max([len(host) for (host, _af) in self.chosts])
            self.say("%-*.*s " % \
                             (maxhostlen, maxhostlen+1, "server"))
        self.say(header)
        self.say(("=" * (maxhostlen + 78 + self.horizontal_slack)) + "\n")
        for peer in self.peers:
            if not showall and \
		    not (CTL_PEER_STATVAL(peer.status)
		      & (CTL_PST_CONFIG|CTL_PST_REACH)):
                if self.debug:
                    self.warn(stderr, "eliding [%d]\n" % peer.associd)
                continue
            if not self.__dogetpeers(header, peer.associd):
                return

    def __assoc_valid(self, line, required=False):
        "Process a numeric associd or index."
        if not line:
            if required:
                self.warn("An associd argument is required.\n")
                return -1
            else:
                return 0
        elif line.startswith("&"):
            try:
                idx = int(line[1:].split()[0])
            except:
                self.warn("Invalid index literal.\n")
                return -1
            if idx not in range(1, len(self.peers)+1):
                self.warn("No such index.\n")
                return -1
            else:
                return self.peers[idx - 1].associd
        else:
            try:
                associd = int(line.split()[0])
            except:
                self.warn("Invalid associd literal.\n")
                return -1
            if associd not in [peer.associd for peer in self.peers]:
                self.warn("Unknown associd.\n")
                return -1
            else:
                return associd

    def __assoc_range_valid(self, line):
        "Try to get a range of assoc IDs."
        tokens = line.split()
        if len(tokens) < 2:
            return ()
        lo = self.__assoc_valid(tokens[0])
        hi = self.__assoc_valid(tokens[1])
        if (hi < lo):
            return ()
        return (lo, hi)

    def __printvars(self, variables, dtype, quiet):
        if self.rawmode:
            if not quiet:
                self.say("status=0x%04x,\n" % self.session.rstatus)
            # C ntpq not only suppressed \r but tried to visibilize
            # high-half characters.  We won't do that unless somebody
            # files a bug, Mode 6 never seems to generate those in
            # variable fetches.
            text = session.response.replace(",\r\n",",\n")
        else:
            if not quiet:
                self.say("status=%04x %s,\n" % \
                         (self.session.rstatus,
                          statustoa(dtype, self.session.rstatus)))

            text = ""
            for (name, value) in variables.items():
                item = "%s=" % name
                if name in ("reftime", "clock", "org", "rec", "xmt"):
                    item += prettydate(value)
                elif name in ("srcadr", "peeradr", "dstadr", "refid"):
                    # C ntpq cooked these in obscure ways.  Since they
                    # came up from the daemon as human-readable
                    # strings this was probably a bad idea, but we'll
                    # leave this case separated in case somebody thinks
                    # re-cooking them is a good idea.
                    item += value
                elif name == "leap":
                    item += ("00", "01", "10", "11")[value]
                elif name == "reach":
                    item += "%03lo" % value
                elif name in("filtdelay", "filtoffset", "filtdisp", "filterror"):
                    item += "\t".join(value.split())
                elif name == "flash":
                    item += "%02x" % value
                    if value == 0:
                        item += " ok"
                    else:
                        # flasher bits
                        tstflagnames = (
                            "pkt_dup",		# BOGON1
                            "pkt_bogus",	# BOGON2
                            "pkt_unsync",	# BOGON3
                            "pkt_denied",	# BOGON4
                            "pkt_auth",		# BOGON5
                            "pkt_stratum",	# BOGON6
                            "pkt_header",	# BOGON7
                            "pkt_autokey",	# BOGON8
                            "pkt_crypto",	# BOGON9
                            "peer_stratum",	# BOGON10
                            "peer_dist",	# BOGON11
                            "peer_loop",	# BOGON12
                            "peer_unreach"	# BOGON13
                        )
                        for (i, n) in enumerate(tstflagnames):
                            if (1 << i) & value:
                                item += tstflagnames + " "
                        item = item[:-1]
                else:
                    item += repr(value)
                item += ", "
                lastcount = 0
                for c in text:
                    if c == '\n':
                        lastcount = 0
                    else:
                        lastcount += 1
                if lastcount + len(item) > 78:
                    text = text[:-1] + "\n"
                text += item
            text = text[:-2] + "\n"
        text = text.replace("'", '"')
        self.say(text)

    def __dolist(self, varlist, associd, op, type):
        "List variables associated with a specified peer."
	 # if we're asking for specific variables don't include the
	 # status header line in the output.
	if self.old_rv:
            quiet = False;
	else:
            quiet = not (not varlist)	# nonempty?
        try:
            variables = self.session.readvar(associd, varlist, op)
        except Mode6Exception as e:
            print(e.message)
            return False
	if len(self.chosts) > 1:
            self.say("server=%s " % self.session.hostname)
	if not variables:
            if associd == 0:
                self.say("No system%s variables returned\n"%
				" clock" if (type == TYPE_CLOCK) else "")
            else:
                self.say("No information returned for%s association %d\n"%
				(" clock" if (type == TYPE_CLOCK) else "",
				associd))
            return True
	if not quiet:
            self.say("associd=%d " % associd);
	self.__printvars(variables, type, quiet)
	return True;

    # Unexposed helper tables and functions end here

    def do_EOF(self, _unused):
        "exit ntpq"
        self.say("\n")
        self.session.close()
        raise SystemExit(0)

    def do_timeout(self, line):
        "set the primary receive time out"
        if line:
            try:
                self.session.primary_timeout = int(line)
            except ValueError:
                print("What?")
        print("primary timeout %d ms" % self.session.primary_timeout)

    def help_timeout(self):
        self.say("""\
function: set the primary receive time out
usage: timeout [ msec ]
""")

    def collect_display(self, associd, variables, decodestatus):
        "Query and display a collection of variables from the system."
        try:
            queried = self.session.readvar(associd, [v[0] for v in variables])
        except Mode6Exception as e:
            print(e.message)
            return
        if decodestatus:
            if associd == 0:
                statype = TYPE_SYS
            else:
                statype = TYPE_PEER
            self.say("associd=%u status=%04x %s,\n" %
                             (associd,
                              self.session.rstatus,
                              statustoa(statype, self.session.rstatus)))
        for (name, legend, fmt) in variables:
            if name not in queried:
                continue
            value = queried[name]
            if fmt in (NTP_STR, NTP_UINT, NTP_INT, NTP_ADD, NTP_ADP):
                self.say("%s  %s\n" % (legend, value))
            elif fmt == NTP_LFP:
                self.say("%s  %s\n" % (legend, prettydate(value)))
            elif fmt == NTP_2BIT:
                self.say("%s  %s\n" % (legend, ("00", "01", "10", "11")[value]))
            elif fmt == NTP_MODE:
                modes = (
                    "unspec", "sym_active", "sym_passive", "client", "server",
                    "broadcast", "control", "private", "bclient"
                )
                try:
                    self.say("%s  %s\n" % (legend, modes[value]))
                except IndexError:
                    self.say("%s  %s%d\n" % (legend, "mode#", value))
            else:
                self.warn("unexpected vc type %s for %s, value %s\n" % (fmt, name, value))

    def do_delay(self, line):
        "set the delay added to encryption time stamps"
        if not line:
            self.say("delay %dms" % self.auth_delay)
        else:
            try:
                self.auth_delay = int(line)
                if self.auth_delay < 0:
                    raise ValueError
            except ValueError:
                self.say("Huh?")

    def help_delay(self):
        self.say("""\
function: set the delay added to encryption time stamps
usage: delay [ msec ]
""")

    def do_host(self, line):
        "specify the host whose NTP server we talk to"
        if not line:
            if self.session.havehost():
                print("current host is %s" % self.session.hostname)
            else:
                print("no current host")
        else:
            tokens = line.split()
            if tokens[0] == '-4':
                session.ai_family = socket.AF_INET
                tokens.pop(0)
            elif tokens[0] == '-6':
                session.ai_family = socket.AF_INET6
                tokens.pop(0)
            if tokens and self.session.openhost(tokens[0], session.ai_family):
                print("current host set to %s" % self.session.hostname)
            elif self.session.havehost():
                print("current host remains %s" % self.session.hostname)
            else:
                print("still no current host")

    def help_host(self):
        self.say("""\
function: specify the host whose NTP server we talk to
usage: host [ -4|-6 ] [ hostname ]
""")

    def do_poll(self, line):
        "poll an NTP server in client mode `n' times"
        # And it's not in the C version, so we're off the hook here
        print("poll not implemented yet")

    def help_poll(self):
        self.say("""\
function: poll an NTP server in client mode `n' times
usage: poll [ n ] [ verbose ]
""")

    def do_passwd(self, line):
        "specify a password to use for authenticated requests"
        self.warn("Authentication is not yet implemented")

    def help_passwd(self):
        self.say("""\
function: specify a password to use for authenticated requests
usage: passwd [  ]
""")

    def do_hostnames(self, line):
        "specify whether hostnames or net numbers are printed"
        if not line:
            pass
        elif line == "yes":
            self.showhostnames = True
        elif line == "no":
            self.showhostnames = False
        else:
            print("What?")
        if self.showhostnames:
            print("hostnames being shown")
        else:
            print("hostnames not being shown")

    def help_hostnames(self):
        self.say("""\
function: specify whether hostnames or net numbers are printed
usage: hostnames [ yes|no ]
""")

    def do_debug(self, line):
        "set/change debugging level"
        if not line:
            pass
        elif line == "more":
            self.debug +=1
        elif line == "less":
            self.debug -= 1
        elif line == "no":
            self.debug = 0
        else:
            try:
                self.debug = int(line)	# C version didn't implement this
            except ValueError:
                print("What?")
        self.session.debug = self.debug
        print("debug level is %d" % self.debug)

    def help_debug(self):
        self.say("""\
function: set/change debugging level
usage: debug [ no|more|less ]
""")

    def do_exit(self, line):
        "exit ntpq"
        self.session.close()
        raise SystemExit(0)

    def help_exit(self):
        self.say("""\
function: exit ntpq
usage: exit
""")
    do_quit = do_exit

    def help_quit(self):
        self.say("""\
function: exit ntpq
usage: quit
""")

    def do_keyid(self, line):
        "set keyid to use for authenticated requests"
        if line:
            try:
                self.session.keyid = int(line)
            except ValueError:
                print("What?")
        if self.session.keyid is None:
            print("no keyid defined")
        else:
            print("keyid is %d" % self.session.keyid)

    def help_keyid(self):
        self.say("""\
function: set keyid to use for authenticated requests
usage: keyid [ key# ]
""")

    def do_version(self, line):
        "print version number"
        print(version)

    def help_version(self):
        self.say("""\
function: print version number
usage: version
""")

    def do_raw(self, line):
        "do raw mode variable output"
        self.rawmode = True
        print("Output set to raw")

    def help_raw(self):
        self.say("""\
function: do raw mode variable output
usage: raw
""")

    def do_cooked(self, line):
        "do cooked mode variable output"
        self.rawmode = False
        print("Output set to cooked")

    def help_cooked(self):
        self.say("""\
function: do cooked mode variable output
usage: cooked
""")

    def do_authenticate(self, line):
        "always authenticate requests to this server"
        if not line:
            pass
        elif line == "yes":
            self.session.always_auth = True
        elif line == "no":
            self.session.always_auth = False
        else:
            print("What?")
        if self.session.always_auth:
            print("authenticated requests being sent")
        else:
            print("unauthenticated requests being sent")

    def help_authenticate(self):
        self.say("""\
function: always authenticate requests to this server
usage: authenticate [ yes|no ]
""")

    def do_ntpversion(self, line):
        "set the NTP version number to use for requests"
        if not line:
            pass
        else:
            try:
                newversion = int(line)
                if newversion >= NTP_OLDVERSION and newversion <= NTP_VERSION:
                    self.pktversion = newversion
                else:
                    print("versions %d to %d, please"
                          % (NTP_OLDVERSION, NTP_VERSION))
            except ValueError:
                print("What?")
        print("NTP version being claimed is %d" % self.pktversion)

    def help_ntpversion(self):
        self.say("""\
function: set the NTP version number to use for requests
usage: ntpversion [ version number ]
""")

    def do_keytype(self, line):
        "set key type to use for authenticated requests"
        self.warn("Authentication is not yet implemented")

    def help_keytype(self):
        self.say("""\
function: set key type to use for authenticated requests, one of:
    DSA, DSA-SHA, MD4, MD5, MDC2, RIPEMD160, SHA, SHA1
usage: keytype [ digest-name ]
""")

    def do_associations(self, line):
        "print list of association IDs and statuses for the server's peers"
        if self.__dogetassoc():
            self.__printassoc(showall=False)

    def help_associations(self):
        self.say("""\
function: print list of association IDs and statuses for the server's peers
usage: associations
""")

    def do_passociations(self, line):
        "print list of associations returned by last associations command"
        self.__printassoc(showall=False)

    def help_passociations(self):
        self.say("""\
function: print list of associations returned by last associations command
usage: passociations
""")

    def do_lassociations(self, line):
        "print list of associations including all client information"
        if self.__dogetassoc():
            self.__printassoc(showall=True)

    def help_lassociations(self):
        self.say("""\
function: print list of associations including all client information
usage: lassociations
""")

    def do_lpassociations(self, line):
        "print last obtained list of associations, including client information"
        self.__printassoc(showall=True)

    def help_lpassociations(self):
        self.say("""\
function: print last obtained list of associations, including client information
usage: lpassociations
""")

    def do_addvars(self, line):
        "add variables to the variable list or change their values"
        if line == "":
            print("usage addvars name[=value][,...]")
            return
        vars_to_add = line.split(',')
        for add_var in vars_to_add:
            try:
                (name, val) = add_var.split("=")
            except ValueError:
                (name, val) = (add_var, "")
            self.uservars[name.strip()] = val.strip()

    def help_addvars(self):
        self.say("""\
function: add variables to the variable list or change their values
usage: addvars name[=value][,...]
""")

    def do_rmvars(self, line):
        "remove variables from the variable list"
        if line == "":
            print("usage rmvars name[,...]")
            return
        vars_to_rm = line.split(',')
        for rm_var in vars_to_rm:
            if rm_var not in self.uservars:
                print("%s is not in the variable list" % rm_var)
            else:
                del self.uservars[rm_var]

    def help_rmvars(self):
        self.say("""\
function: remove variables from the variable list
usage: rmvars name[,...]
""")

    def do_clearvars(self, line):
        "remove all variables from the variable list"
        self.uservars.clear()

    def help_clearvars(self):
        self.say("""\
function: remove all variables from the variable list
usage: clearvars
""")

    def do_showvars(self, line):
        "print variables on the variable list"
        if len(self.uservars) == 0:
            print("No variables on list.")
        for (name, value) in self.uservars.items():
            if value:
                print("%s=%s" % (name, value))
            else:
                print(name)

    def help_showvars(self):
        self.say("""\
function: print variables on the variable list
usage: showvars
""")

    def do_readlist(self, line):
        "read the system or peer variables included in the variable list"
        associd = self.__assoc_valid(line)
        qtype = TYPE_SYS if associd == 0 else TYPE_PEER
        self.__dolist(self.uservars.keys(), associd, CTL_OP_READVAR, qtype)

    def help_readlist(self):
        self.say("""\
function: read the system or peer variables included in the variable list
usage: readlist [ assocID ]
""")

    def do_rl(self, line):
        "read the system or peer variables included in the variable list"
        self.do_readlist(line)

    def help_rl(self):
        self.say("""\
function: read the system or peer variables included in the variable list
usage: rl [ assocID ]
""")

    def do_writelist(self, line):
        "write the system or peer variables included in the variable list"
        pass

    def help_writelist(self):
        self.say("""\
function: write the system or peer variables included in the variable list
usage: writelist [ assocID ]
""")

    def do_readvar(self, line):
        "read system or peer variables"
        associd = self.__assoc_valid(line)
        qtype = TYPE_SYS if associd == 0 else TYPE_PEER
        self.__dolist(line.split()[1:], associd, CTL_OP_READVAR, qtype)

    def help_readvar(self):
        self.say("""\
function: read system or peer variables
usage: readvar [ assocID ] [ varname1 ] [ varname2 ] [ varname3 ]
""")

    def do_rv(self, line):
        "read system or peer variables"
        self.do_readvar(line)

    def help_rv(self):
        self.say("""\
function: read system or peer variables
usage: rv [ assocID ] [ varname1 ] [ varname2 ] [ varname3 ]
""")

    def do_writevar(self, line):
        "write system or peer variables"
        pass

    def help_writevar(self):
        self.say("""\
function: write system or peer variables
usage: writevar assocID name=value,[...]
""")

    def do_mreadlist(self, line):
        "read the peer variables in the variable list for multiple peers"
        idrange = self.__assoc_range_valid()
        if not idrange:
            return
        varlist = line.split()[2:]
        for associd in idrange:
            if (associd != idrange[0]):
                self.say("\n")
            if not self__dolist(self.uservars,
                                associd, CTL_OP_READVAR, TYPE_PEER):
                return

    def help_mreadlist(self):
        self.say("""\
function: read the peer variables in the variable list for multiple peers
usage: mreadlist assocIDlow assocIDhigh
""")

    def do_mrl(self, line):
        "read the peer variables in the variable list for multiple peers"
        self.do_mreadlist(line)

    def help_mrl(self):
        self.say("""\
function: read the peer variables in the variable list for multiple peers
usage: mrl assocIDlow assocIDhigh
""")

    def do_mreadvar(self, line):
        "read peer variables from multiple peers"
        idrange = self.__assoc_range_valid()
        if not idrange:
            return
        varlist = line.split()[2:]
        for associd in idrange:
            if (associd != idrange[0]):
                self.say("\n")
            if not self__dolist(varlist, associd, CTL_OP_READVAR, TYPE_PEER):
                return

    def help_mreadvar(self):
        self.say("""\
function: read peer variables from multiple peers
usage: mreadvar assocIDlow assocIDhigh [ name=value[,...] ]
""")

    def do_mrv(self, line):
        "read peer variables from multiple peers"
        self.do_mreadvar(line)

    def help_mrv(self):
        self.say("""\
function: read peer variables from multiple peers
usage: mrv assocIDlow assocIDhigh [ name=value[,...] ]
""")

    def do_clocklist(self, line):
        "read the clock variables included in the variable list"
        self.__dolist(self.uservars.keys(),
                      self.__assoc_valid(line), CTL_OP_READVAR, TYPE_CLOCK)

    def help_clocklist(self):
        self.say("""\
function: read the clock variables included in the variable list
usage: clocklist [ assocID ]
""")

    def do_cl(self, line):
        "read the clock variables included in the variable list"
        self.do_clocklist(line)

    def help_cl(self):
        self.say("""\
function: read the clock variables included in the variable list
usage: cl [ assocID ]
""")

    def do_clockvar(self, line):
        "read clock variables"
        self.__dolist(line.split()[1:], self.__assoc_valid(line),
                      CTL_OP_READCLOCK, TYPE_CLOCK)

    def help_clockvar(self):
        self.say("""\
function: read clock variables
usage: clockvar [ assocID ] [ name=value[,...] ]
""")

    def do_cv(self, line):
        "read clock variables"
        self.do_clockvar(line)

    def help_cv(self):
        self.say("""\
function: read clock variables
usage: cv [ assocID ] [ name=value[,...] ]
""")

    def do_pstats(self, line):
        "show statistics for a peer"
        pstats = (
            ("srcadr",		"remote host:         ", NTP_ADD),
            ("dstadr",		"local address:       ", NTP_ADD),
            ("timerec",		"time last received:  ", NTP_STR),
            ("timer",		"time until next send:", NTP_STR),
            ("timereach",	"reachability change: ", NTP_STR),
            ("sent",		"packets sent:        ", NTP_STR),
            ("received",	"packets received:    ", NTP_STR),
            ("badauth",		"bad authentication:  ", NTP_STR),
            ("bogusorg",	"bogus origin:        ", NTP_STR),
            ("oldpkt",		"duplicate:           ", NTP_STR),
            ("seldisp",		"bad dispersion:      ", NTP_STR),
            ("selbroken",	"bad reference time:  ", NTP_STR),
            ("candidate",	"candidate order:     ", NTP_STR),
        )
        associd = self.__assoc_valid(line)
        if associd >= 0:
            self.collect_display(associd=associd,
                                 variables=pstats, decodestatus=True)

    def help_pstats(self):
        self.say("""\
function: show statistics for a peer
usage: pstats assocID
""")

    def do_peers(self, line):
        "obtain and print a list of the server's peers [IP version]"
        self.__dopeers(showall=False, header=self.__peerheader)

    def help_peers(self):
        self.say("""\
function: obtain and print a list of the server's peers [IP version]
usage: peers
""")

    def do_apeers(self, line):
        "obtain and print a list of the server's peers and their assocIDs [IP version]"
        self.__dopeers(showall=False, header=self.__apeerheader)

    def help_apeers(self):
        self.say("""\
function: obtain and print a list of the server's peers and their assocIDs [IP version]
usage: apeers
""")

    def do_lpeers(self, line):
        "obtain and print a list of all peers and clients [IP version]"
        self.__dopeers(showall=True, header=self.__peerheader)

    def help_lpeers(self):
        self.say("""\
function: obtain and print a list of all peers and clients [IP version]
usage: lpeers
""")

    def do_opeers(self, line):
        "print peer list the old way, with dstadr shown rather than refid [IP version]"
        self.__dopeers(showall=False, header=self.__opeerheader)

    def help_opeers(self):
        self.say("""\
function: print peer list the old way, with dstadr shown rather than refid [IP version]
usage: opeers
""")

    def do_lopeers(self, line):
        "obtain and print a list of all peers and clients showing dstadr [IP version]"
        self.__dopeers(showall=True, header=self.__opeerheader)

    def help_lopeers(self):
        self.say("""\
function: obtain and print a list of all peers and clients showing dstadr [IP version]
usage: lopeers
""")

    def do_config(self, line):
        "send a remote configuration command to ntpd"
        pass

    def help_config(self):
        self.say("""\
function: send a remote configuration command to ntpd
usage: config <configuration command line>
""")

    def do_config_from_file(self, line):
        "configure ntpd using the configuration filename"
        pass

    def help_config_from_file(self):
        self.say("""\
function: configure ntpd using the configuration filename
usage: config_from_file <configuration filename>
""")

    def do_mrulist(self, line):
        "display the list of most recently seen source addresses, tags mincount=... resall=0x... resany=0x..."
        pass

    def help_mrulist(self):
        self.say("""\
function: display the list of most recently seen source addresses, tags mincount=... resall=0x... resany=0x...
usage: mrulist [ tag=value ] [ tag=value ] [ tag=value ] [ tag=value ]
""")

    def do_ifstats(self, line):
        "show statistics for each local address ntpd is using"
        pass

    def help_ifstats(self):
        self.say("""\
function: show statistics for each local address ntpd is using
usage: ifstats
""")

    def do_reslist(self, line):
        "show ntpd access control list"
        pass

    def help_reslist(self):
        self.say("""\
function: show ntpd access control list
usage: reslist
""")

    def do_sysinfo(self, _line):
        "display system summary"
        sysinfo = (
            ("peeradr",		"system peer:      ", NTP_ADP),
            ("peermode",	"system peer mode: ", NTP_MODE),
            ("leap",		"leap indicator:   ", NTP_2BIT),
            ("stratum",		"stratum:          ", NTP_STR),
            ("precision",	"log2 precision:   ", NTP_STR),
            ("rootdelay",	"root delay:       ", NTP_STR),
            ("rootdisp",	"root dispersion:  ", NTP_STR),
            ("refid",		"reference ID:     ", NTP_STR),
            ("reftime",		"reference time:   ", NTP_LFP),
            ("sys_jitter",	"system jitter:    ", NTP_STR),
            ("clk_jitter",	"clock jitter:     ", NTP_STR),
            ("clk_wander",	"clock wander:     ", NTP_STR),
            ("bcastdelay",	"broadcast delay:  ", NTP_STR),
            ("authdelay",	"symm. auth. delay:", NTP_STR),
        )
        self.collect_display(associd=0, variables=sysinfo, decodestatus=True)

    def help_sysinfo(self):
        self.say("""\
function: display system summary
usage: sysinfo
""")

    def do_kerninfo(self, _line):
        "display kernel loop and PPS statistics"
        kerninfo = (
            ("koffset",		"pll offset:          ", NTP_STR),
            ("kfreq",		"pll frequency:       ", NTP_STR),
            ("kmaxerr",		"maximum error:       ", NTP_STR),
            ("kesterr",		"estimated error:     ", NTP_STR),
            ("kstflags",	"kernel status:       ", NTP_STR),
            ("ktimeconst",	"pll time constant:   ", NTP_STR),
            ("kprecis",		"precision:           ", NTP_STR),
            ("kfreqtol",	"frequency tolerance: ", NTP_STR),
            ("kppsfreq",	"pps frequency:       ", NTP_STR),
            ("kppsstab",	"pps stability:       ", NTP_STR),
            ("kppsjitter",	"pps jitter:          ", NTP_STR),
            ("kppscalibdur",	"calibration interval ", NTP_STR),
            ("kppscalibs",	"calibration cycles:  ", NTP_STR),
            ("kppsjitexc",	"jitter exceeded:     ", NTP_STR),
            ("kppsstbexc",	"stability exceeded:  ", NTP_STR),
            ("kppscaliberrs",	"calibration errors:  ", NTP_STR),
        )
        self.collect_display(associd=0, variables=kerninfo, decodestatus=True)

    def help_kerninfo(self):
        self.say("""\
function: display kernel loop and PPS statistics
usage: kerninfo
""")

    def do_sysstats(self, _line):
        "display system uptime and packet counts"
        sysstats = (
            ("ss_uptime",	"uptime:               ", NTP_STR),
            ("ss_reset",	"sysstats reset:       ", NTP_STR),
            ("ss_received",	"packets received:     ", NTP_STR),
            ("ss_thisver",	"current version:      ", NTP_STR),
            ("ss_oldver",	"older version:        ", NTP_STR),
            ("ss_badformat",	"bad length or format: ", NTP_STR),
            ("ss_badauth",	"authentication failed:", NTP_STR),
            ("ss_declined",	"declined:             ", NTP_STR),
            ("ss_restricted",	"restricted:           ", NTP_STR),
            ("ss_limited",	"rate limited:         ", NTP_STR),
            ("ss_kodsent",	"KoD responses:        ", NTP_STR),
            ("ss_processed",	"processed for time:   ", NTP_STR),
        )
        self.collect_display(associd=0, variables=sysstats, decodestatus=False)

    def help_sysstats(self):
        self.say("""\
function: display system uptime and packet counts
usage: sysstats
""")

    def do_monstats(self, _line):
        "display monitor (mrulist) counters and limits"
        monstats = (
            ("mru_enabled",	"enabled:            ", NTP_STR),
            ("mru_depth",	"addresses:          ", NTP_STR),
            ("mru_deepest",	"peak addresses:     ", NTP_STR),
            ("mru_maxdepth",	"maximum addresses:  ", NTP_STR),
            ("mru_mindepth",	"reclaim above count:", NTP_STR),
            ("mru_maxage",	"reclaim older than: ", NTP_STR),
            ("mru_mem",		"kilobytes:          ", NTP_STR),
            ("mru_maxmem",	"maximum kilobytes:  ", NTP_STR),
        )
        self.collect_display(associd=0, variables=monstats, decodestatus=False)

    def help_monstats(self):
        self.say("""\
function: display monitor (mrulist) counters and limits
usage: monstats
""")

    def do_authinfo(self, _line):
        "display symmetric authentication counters"
        authinfo = (
            ("authreset",	"time since reset:", NTP_STR),
            ("authkeys",	"stored keys:     ", NTP_STR),
            ("authfreek",	"free keys:       ", NTP_STR),
            ("authklookups",	"key lookups:     ", NTP_STR),
            ("authknotfound",	"keys not found:  ", NTP_STR),
            ("authkuncached",	"uncached keys:   ", NTP_STR),
            ("authkexpired",	"expired keys:    ", NTP_STR),
            ("authencrypts",	"encryptions:     ", NTP_STR),
            ("authdecrypts",	"decryptions:     ", NTP_STR),
        )
        self.collect_display(associd=0, variables=authinfo, decodestatus=False)

    def help_authinfo(self):
        self.say("""\
function: display symmetric authentication counters
usage: authinfo
""")

    def do_iostats(self, _line):
        "display network input and output counters"
        iostats = (
            ("iostats_reset",	"time since reset:     ", NTP_STR),
            ("total_rbuf",	"receive buffers:      ", NTP_STR),
            ("free_rbuf",	"free receive buffers: ", NTP_STR),
            ("used_rbuf",	"used receive buffers: ", NTP_STR),
            ("rbuf_lowater",	"low water refills:    ", NTP_STR),
            ("io_dropped",	"dropped packets:      ", NTP_STR),
            ("io_ignored",	"ignored packets:      ", NTP_STR),
            ("io_received",	"received packets:     ", NTP_STR),
            ("io_sent",		"packets sent:         ", NTP_STR),
            ("io_sendfailed",	"packet send failures: ", NTP_STR),
            ("io_wakeups",	"input wakeups:        ", NTP_STR),
            ("io_goodwakeups",	"useful input wakeups: ", NTP_STR),
        )
        self.collect_display(associd=0, variables=iostats, decodestatus=False)

    def help_iostats(self):
        self.say("""\
function: display network input and output counters
usage: iostats
""")

    def do_timerstats(self, line):
        "display interval timer counters"
        timerstats = (
            ("timerstats_reset",	"time since reset:  ", NTP_STR),
            ("timer_overruns",		"timer overruns:    ", NTP_STR),
            ("timer_xmts",		"calls to transmit: ", NTP_STR),
        )
        self.collect_display(associd=0, variables=timerstats, decodestatus=False)

    def help_timerstats(self):
        self.say("""\
function: display interval timer counters
usage: timerstats
""")

# Default values we use.
DEFHOST 	= "localhost"	# default host name

# Requests are automatically retried once, so total timeout with no
# response is a bit over 2 * DEFTIMEOUT, or 10 seconds.  At the other
# extreme, a request eliciting 32 packets of responses each for some
# reason nearly DEFSTIMEOUT seconds after the prior in that series,
# with a single packet dropped, would take around 32 * DEFSTIMEOUT, or
# 93 seconds to fail each of two times, or 186 seconds.
# Some commands involve a series of requests, such as "peers" and
# "mrulist", so the cumulative timeouts are even longer for those.
DEFDELAY	= 0x51EB852	# 20 milliseconds, l_fp fraction
MAXVARLEN	= 256		# maximum length of a variable name
MAXVALLEN	= 2048		# maximum length of a variable value
MAXOUTLINE	= 72		# maximum length of an output line
SCREENWIDTH	= 76		# nominal screen width in columns

# Macro definitions we use
def ISSPACE(c):	return ((c) == ' ' or (c) == '\t')
def ISEOL(c):	return ((c) == '\n' or (c) == '\r' or (c) == '\0')

#
# main - parse arguments and handle options
#

usage = '''
USAGE: ntpq [-46dphinOV] [-c str] [-D lvl] [ host ...]
  Flg Arg Option-Name    Description
   -4 no  ipv4           Force IPv4 DNS name resolution
				- prohibits the option 'ipv6'
   -6 no  ipv6           Force IPv6 DNS name resolution
				- prohibits the option 'ipv4'
   -c Str command        run a command and exit
				- may appear multiple times
   -d no  debug-level    Increase output debug message level
				- may appear multiple times
   -D Str set-debug-level Set the output debug message level
				- may appear multiple times
   -h no  help           Print a usage message.
   -p no  peers          Print a list of the peers
				- prohibits the option 'interactive'
   -i no  interactive    Force ntpq to operate in interactive mode
				- prohibits these options:
				command
				peers
   -n no  numeric        numeric host addresses
   -O no  old-rv         Always output status line with readvar
   -V opt version        Output version information and exit
   -w no  wide           enable wide display of addresses
'''

if __name__ == '__main__':
    setprogname("pyntpq")
    #init_auth()

    try:
        (options, arguments) = getopt.getopt(sys.argv[1:],
                                             "46c:dD:hinOpVw",
                                             ["ipv4","ipv6", "command",
                                              "debug", "set-debug-level",
                                              "help", "interactive", "numeric",
                                              "old-rv", "peers", "version",
                                              "wide"])
    except getopt.GetoptError as e:
        print(e)
        raise SystemExit(1)
    progname = sys.argv[0]

    session = Mode6Session()
    interpreter = Ntpq(session)

    for (switch, val) in options:
        if switch in ("-4", "--ipv4"):
            interpreter.ai_family = socket.AF_INET
        elif switch in ("-6", "--ipv6"):
            interpreter.ai_family = socket.AF_INET6
        elif switch in ("-c", "--command"):
            interpreter.ccmds.append(val)
        elif switch in ("-d", "--debug"):
            interpreter.debug += 1
            session.debug += 1
        elif switch in ("-D", "--set-debug-level"):
            session.debug = interpreter.debug = int(val)
        elif switch in ("-h", "--help"):
            print(usage)
            raise SystemExit(0)
        elif switch in ("-i", "--interactive"):
            interpreter.interactive = True
        elif switch in ("-n", "--numeric"):
            interpreter.showhostnames = False
        elif switch in ("-O", "--old-rv"):
            interpreter.old_rv = True
        elif switch in ("-p", "--peers"):
            interpreter.ccmds.append("peers")
        elif switch in ("-V", "--version"):
            print("ntpq %s\n" % version)
            raise SystemExit(0)
        elif switch in ("-w", "--wide"):
            interpreter.wideremote = True
        else:
            self.warn("Unknown command line switch or missing argument.\n")
            self.warn(usage)
            raise SystemExit(1)

    if interpreter.interactive and len(interpreter.ccmds) > 0:
        self.warn("%s: invalid option combination.\n" % progname)
        raise SystemExit(1)

    if len(arguments) == 0:
        interpreter.chosts.append((DEFHOST, session.ai_family))
    else:
        for token in arguments:
            if token.startswith("-"):
                if '4' == token[1]:
                    session.ai_family = socket.AF_INET
                elif '6' == token[1]:
                    session.ai_family = socket.AF_INET6
            else:
                interpreter.chosts.append((token, session.ai_family))

    if len(interpreter.ccmds) == 0 and not interpreter.interactive and os.isatty(0) and os.isatty(1):
        interpreter.interactive = True

    try:
        if len(interpreter.ccmds) == 0:
            if len(interpreter.chosts) > 1:
                self.warn("ntpq can only work interactively on one host.")
                interpreter.chosts = interpreter.chosts[:1]
            session.openhost(*interpreter.chosts[0])
            interpreter.cmdloop()
        else:
            for ihost in interpreter.chosts:
                if session.openhost(*ihost):
                    for cmd in interpreter.ccmds:
                        interpreter.onecmd(cmd)
                    session.close()
        raise SystemExit(0)
    except KeyboardInterrupt:
        self.say("\n")
# end
