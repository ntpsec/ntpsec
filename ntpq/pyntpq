#!/usr/bin/env python
#
# pyntpq - query an NTP server using mode 6 commands
#
# This is a direct translation of the ntpq C code, initially written to work as
# much like it as possible. Eventually it will replace the C version.
#
# Due to a limitation of the Python Cmd class, the ":config" and
# ":config-from-file "command" lose their colons.
#
# SPDX-License-Identifier: BSD-2-clause
from __future__ import print_function, division

import os, sys, getopt, cmd, errno, curses, curses.ascii
import socket, select, struct, shlex

from ntp.packet import *

# This import only works on Unixes.  The intention is to enable
# Ctrl-P, Ctrl-N, and friends in Cmd.
try:
    import readline
except ImportError:
    pass

version = "ntpq-py v1"

# General notes on Python 2/3 compatibility:
#
# This code uses the following strategy to allow it to run on both Python 2
# and Python 3:
#
# - Use binary I/O to read/write data from/to files and subprocesses;
#   where the exact bytes are important (such as in checking for
#   modified files), use the binary data directly
#
# - Use latin-1 encoding to transform binary data to/from Unicode when
#   necessary for operations where Python 3 expects Unicode; the
#   polystr and polybytes functions are used to do this so that
#   when running on Python 2, the byte string data is used unchanged;
#   also, the make_wrapper function constructs a text stream that can
#   wrap a file opened in binary mode for cases where a file object
#   that can be passed around from function to function is needed
#
# - Construct custom stdin, stdout, and stderr streams when running
#   on Python 3 that force latin-1 encoding, and wrap them around the
#   underlying binary buffers (in Python 2, the streams are binary
#   and are used unchanged); this ensures that the same transformation
#   is done on data from/to the standard streams, as is done on binary
#   data from/to files and subprocesses; the make_std_wrapper function
#   does this

master_encoding = 'latin-1'

if str is bytes:  # Python 2
    polystr = str
    polybytes = bytes

    def string_escape(s):
        return s.decode('string_escape')

    def make_wrapper(fp):
        return fp

else:  # Python 3

    def polystr(o):
        "Polymorphic string factory function"
        if isinstance(o, str):
            return o
        if not isinstance(o, bytes):
            return str(o)
        return str(o, encoding=master_encoding)

    def polybytes(s):
        "Polymorphic string encoding function"
        if isinstance(s, bytes):
            return s
        if not isinstance(s, str):
            return bytes(s)
        return bytes(s, encoding=master_encoding)

    def string_escape(s):
        "Polymorphic string_escape/unicode_escape"
        # This hack is necessary because Unicode strings in Python 3 don't
        # have a decode method, so there's no simple way to ask it for the
        # equivalent of decode('string_escape') in Python 2. This function
        # assumes that it will be called with a Python 3 'str' instance
        return s.encode(master_encoding).decode('unicode_escape')

    def make_wrapper(fp):
        "Wrapper factory function to enforce master encoding"
        # This can be used to wrap normally binary streams for API
        # compatibility with functions that need a text stream in
        # Python 3; it ensures that the binary bytes are decoded using
        # the master encoding we use to turn bytes to Unicode in
        # polystr above
        # newline="\n" ensures that Python 3 won't mangle line breaks
        return io.TextIOWrapper(fp, encoding=master_encoding, newline="\n")

    def make_std_wrapper(stream):
        "Standard input/output wrapper factory function"
        # This ensures that the encoding of standard output and standard
        # error on Python 3 matches the master encoding we use to turn
        # bytes to Unicode in polystr above
        # line_buffering=True ensures that interactive command sessions work as expected
        return io.TextIOWrapper(stream.buffer, encoding=master_encoding, newline="\n", line_buffering=True)

    sys.stdin = make_std_wrapper(sys.stdin)
    sys.stdout = make_std_wrapper(sys.stdout)
    sys.stderr = make_std_wrapper(sys.stderr)

# NTP-specific parts resume here

# Flags for forming descriptors. (FIXME: may not be needed in Python)
OPT		= 0x80	# this argument is optional, or'd with type */
NO		= 0x0
NTP_STR		= 0x1	# string argument
NTP_UINT	= 0x2	# unsigned integer
NTP_INT		= 0x3	# signed integer
NTP_ADD		= 0x4	# IP network address
IP_VERSION	= 0x5	# IP version
NTP_ADP		= 0x6	# IP address and port
NTP_LFP		= 0x7	# NTP timestamp
NTP_MODE	= 0x8	# peer mode
NTP_2BIT	= 0x9	# leap bits

# Format values
PADDING	= 0
HA	= 1	# host address 
NA	= 2	# network address 
LP	= 3	# leap (print in binary) 
RF	= 4	# refid (sometimes string, sometimes not) 
AR	= 5	# array of times 
FX	= 6	# test flags 
TS	= 7	# l_fp timestamp in hex 
OC	= 8	# integer, print in octal 
EOV	= 255	# end of table 

# For the most part ntpq simply displays what ntpd provides in the
# mostly plain-text mode 6 responses.  A few variable names are by
# default "cooked" to provide more human-friendly output.  This is
# a dictionary of cooked variables.
cookedvars = {
    "leap":		LP,
    "reach":		OC,
    "refid":		RF,
    "reftime":		TS,
    "clock":		TS,
    "org":		TS,
    "rec":		TS,
    "xmt":		TS,
    "flash":		FX,
    "srcadr":		HA,
    "peeradr":		HA,	# compat with others 
    "dstadr":		NA,
    "filtdelay":	AR,
    "filtoffset":	AR,
    "filtdisp":		AR,
    "filterror":	AR,	# compat with others 
}

uservars = {
}

# flasher bits 
tstflagnames = (
	"pkt_dup",		# BOGON1 
	"pkt_bogus",		# BOGON2 
	"pkt_unsync",		# BOGON3 
	"pkt_denied",		# BOGON4 
	"pkt_auth",		# BOGON5 
	"pkt_stratum",		# BOGON6 
	"pkt_header",		# BOGON7 
	"pkt_autokey",		# BOGON8 
	"pkt_crypto",		# BOGON9 
	"peer_stratum",		# BOGON10 
	"peer_dist",		# BOGON11 
	"peer_loop",		# BOGON12 
	"peer_unreach"		# BOGON13 
)

class ntpq_interpreter(cmd.Cmd):
    "ntpq command interpreter"
    def __init__(self, session):
        cmd.Cmd.__init__(self)
        self.session = session
        self.prompt = "pyntpq> "
        self.interactive       = False	# set to True when we should prompt
        self.old_rv            = False	# use old readvars behavior?
        #self.auth_keyid   = 0		# Keyid used for authentication.
        #self.auth_keytype = "NID_md5"	# MD5 (FIXME: string value is a dummy)
        #self.auth_hashlen = 16		# MD5
        self.rawmode           = False	# Flag which indicates raw mode output. 
        self.showhostnames     = True	# If false, display numeric IPs
	#self.l_fp delay_time		# delay time
        self.wideremote = False		# show wide remote names? 
        self.ccmds = []			# Queued commands
        self.chosts = []		# Command-line hosts
        self.debug = 0
    def do_EOF(self, _unused):
        "exit ntpq"
        sys.stdout.write("\n")
        self.session.close()
        raise SystemExit(0)
    def do_timeout(self, line):
        "set the primary receive time out"
        if line:
            try:
                self.session.primary_timeout = int(line)
            except ValueError:
                print("What?")
        print("primary timeout %d ms" % self.session.primary_timeout)
    def help_timeout(self):
        sys.stdout.write("""\
function: set the primary receive time out
usage: timeout [ msec ]
""")
    def do_delay(self, line):
        "set the delay added to encryption time stamps"
        sys.stderr.write("Authentication is not yet implemented")
    def help_delay(self):
        sys.stdout.write("""\
function: set the delay added to encryption time stamps
usage: delay [ msec ]
""")
    def do_host(self, line):
        "specify the host whose NTP server we talk to"
        if not line:
            if self.session.havehost():
                print("current host is %s" % self.session.name)
            else:
                print("no current host")
        else:
            tokens = line.split()
            if tokens[0] == '-4':
                session.ai_family = socket.AF_INET
                tokens.pop(0)
            elif tokens[0] == '-6':
                session.ai_family = socket.AF_INET6
                tokens.pop(0)
            if tokens and self.session.openhost(tokens[0],session.ai_family):
                print("current host set to %s" % self.session.name)
            elif self.session.havehost():
                print("current host remains %s" % self.session.name)
            else:
                print("still no current host")        
    def help_host(self):
        sys.stdout.write("""\
function: specify the host whose NTP server we talk to
usage: host [ -4|-6 ] [ hostname ]
""")
    def do_poll(self, line):
        "poll an NTP server in client mode `n' times"
        print("poll not implemented yet")
    def help_poll(self):
        sys.stdout.write("""\
function: poll an NTP server in client mode `n' times
usage: poll [ n ] [ verbose ]
""")
    def do_passwd(self, line):
        "specify a password to use for authenticated requests"
        sys.stderr.write("Authentication is not yet implemented")
    def help_passwd(self):
        sys.stdout.write("""\
function: specify a password to use for authenticated requests
usage: passwd
""")
    def do_hostnames(self, line):
        "specify whether hostnames or net numbers are printed"
        if not line:
            pass
        elif line == "yes":
            self.showhostnames = True
        elif line == "no":
            self.showhostnames = False
        else:
            print("What?")
        if self.showhostnames:
            print("hostnames being shown")
        else:
            print("hostnames not being shown")
    def help_hostnames(self):
        sys.stdout.write("""\
function: specify whether hostnames or net numbers are printed
usage: hostnames [ yes|no ]
""")
    def do_debug(self, line):
        "set/change debugging level"
        if not line:
            pass
        elif line == "more":
            self.debug +=1
        elif line == "less":
            self.debug -= 1
        elif line == "no":
            self.debug = 0
        else:
            try:
                self.debug = int(line)	# C version didn't implement this
            except ValueError:
                print("What?")
        self.session.debug = self.debug
        print("debug level is %d" % self.debug)
    def help_debug(self):
        sys.stdout.write("""\
function: set/change debugging level
usage: debug [ no|more|less ]
""")
    def do_exit(self, line):
        "exit ntpq"
        self.session.close()
        raise SystemExit(0)
    def help_exit(self):
        sys.stdout.write("""\
function: exit ntpq
usage: exit
""")
    do_quit = do_exit
    def help_quit(self):
        sys.stdout.write("""\
function: exit ntpq
usage: quit
""")
    def do_keyid(self, line):
        "set keyid to use for authenticated requests"
        if line:
            try:
                self.session.keyid = int(line)
            except ValueError:
                print("What?")
        if self.session.keyid is None:
            print("no keyid defined")
        else:
            print("keyid is %d" % self.session.keyid)
    def help_keyid(self):
        sys.stdout.write("""\
function: set keyid to use for authenticated requests
usage: keyid [ key# ]
""")
    def do_version(self, line):
        "print version number"
        print(version)
    def help_version(self):
        sys.stdout.write("""\
function: print version number
usage: version
""")
    def do_raw(self, line):
        "do raw mode variable output"
        self.rawmode = True
        print("Output set to raw")
    def help_raw(self):
        sys.stdout.write("""\
function: do raw mode variable output
usage: raw
""")
    def do_cooked(self, line):
        "do cooked mode variable output"
        self.rawmode = False
        print("Output set to cooked")
    def help_cooked(self):
        sys.stdout.write("""\
function: do cooked mode variable output
usage: cooked
""")
    def do_authenticate(self, line):
        "always authenticate requests to this server"
        if not line:
            pass
        elif line == "yes":
            self.session.always_auth = True
        elif line == "no":
            self.session.always_auth = False
        else:
            print("What?")
        if self.session.always_auth:
            print("authenticated requests being sent")
        else:
            print("unauthenticated requests being sent")
    def help_authenticate(self):
        sys.stdout.write("""\
function: always authenticate requests to this server
usage: authenticate [ yes|no ]
""")
    def do_ntpversion(self, line):
        "set the NTP version number to use for requests"
        if not line:
            pass
        else:
            try:
                newversion = int(line)
                if newversion >= NTP_OLDVERSION and newversion <= NTP_VERSION:
                    self.pktversion = newversion
                else:
                    print("versions %d to %d, please"
                          % (NTP_OLDVERSION, NTP_VERSION))
            except ValueError:
                print("What?")
        print("NTP version being claimed is %d" % self.pktversion)
    def help_ntpversion(self):
        sys.stdout.write("""\
function: set the NTP version number to use for requests
usage: ntpversion [ version number ]
""")
    def do_keytype(self, line):
        "set key type to use for authenticated requests"
        sys.stderr.write("Authentication is not yet implemented")
        pass
    def help_keytype(self):
        sys.stdout.write("""\
function: set key type to use for authenticated requests (des|md5)
usage: keytype [ key type (md5|des) ]
""")
    def do_exercise(self, line):
        "Exercise the protocol - low level"
        tokens = shlex.split(line)
        if len(tokens) == 0:
            print("Requires an opcode, followed by optional associd and payload string")
            return
        elif len(tokens) == 1:
            tokens.append(0)
            tokens.append("")
        elif len(tokens) == 2:
            tokens.append("")
        msg = self.session.doquery(int(tokens[0]),
                                   int(tokens[1]),
                                   polybytes(tokens[2]))
        if msg:
            print(msg)
    def do_associations(self, line):
        "print list of association IDs and statuses for the server's peers"
        pass
    def do_passociations(self, line):
        "print list of associations returned by last associations command"
        pass
    def do_lassociations(self, line):
        "print list of associations including all client information"
        pass
    def do_lpassociations(self, line):
        "print last obtained list of associations, including client information"
        pass
    def do_addvars(self, line):
        "add variables to the variable list or change their values"
        if line == "":
            print("usage addvars name[=value][,...]")
            return

        vars_to_add = line.split(',')
        for add_var in vars_to_add:
            uservars[add_var.split("=")[0].strip()] = add_var.split("=")[1].strip()

    def do_rmvars(self, line):
        "remove variables from the variable list"
        if add_var == "":
            print("usage rmvars name[,...]")
            return

        vars_to_add = line.split(',')
        for add_var in vars_to_add:
            if add_var not in uservars:
                print ("%s is not in the variable list" % add_var.split("=")[0])
            else:
                del uservars[add_var]

    def do_clearvars(self, line):
        "remove all variables from the variable list"
        uservars.clear()

    def do_showvars(self, line):
        "print variables on the variable list"
        if len(uservars) == 0:
            print ("No variables on list.")
        for name in uservars:
            print ("%s=%s" % (name, uservars[name]))

    def do_readlist(self, line):
        "read the system or peer variables included in the variable list"
        pass
    def do_rl(self, line):
        "read the system or peer variables included in the variable list"
        pass
    def do_writelist(self, line):
        "write the system or peer variables included in the variable list"
        pass
    def do_readvar(self, line):
        "read system or peer variables"
        pass
    def do_rv(self, line):
        "read system or peer variables"
        pass
    def do_writevar(self, line):
        "write system or peer variables"
        pass
    def do_mreadlist(self, line):
        "read the peer variables in the variable list for multiple peers"
        pass
    def do_mrl(self, line):
        "read the peer variables in the variable list for multiple peers"
        pass
    def do_mreadvar(self, line):
        "read peer variables from multiple peers"
        pass
    def do_mrv(self, line):
        "read peer variables from multiple peers"
        pass
    def do_clocklist(self, line):
        "read the clock variables included in the variable list"
        pass
    def do_cl(self, line):
        "read the clock variables included in the variable list"
        pass
    def do_clockvar(self, line):
        "read clock variables"
        pass
    def do_cv(self, line):
        "read clock variables"
        pass
    def do_pstats(self, line):
        "show statistics for a peer"
        pass
    def do_peers(self, line):
        "obtain and print a list of the server's peers [IP version]"
        pass
    def do_apeers(self, line):
        "obtain and print a list of the server's peers and their assocIDs [IP version]"
        pass
    def do_lpeers(self, line):
        "obtain and print a list of all peers and clients [IP version]"
        pass
    def do_opeers(self, line):
        "print peer list the old way, with dstadr shown rather than refid [IP version]"
        pass
    def do_lopeers(self, line):
        "obtain and print a list of all peers and clients showing dstadr [IP version]"
        pass
    def do_config(self, line):
        "send a remote configuration command to ntpd"
        pass
    def do_config_from_file(self, line):
        "configure ntpd using the configuration filename"
        pass
    def do_mrulist(self, line):
        "display the list of most recently seen source addresses, tags mincount=... resall=0x... resany=0x..."
        pass
    def do_ifstats(self, line):
        "show statistics for each local address ntpd is using"
        pass
    def do_reslist(self, line):
        "show ntpd access control list"
        pass
    def do_sysinfo(self, line):
        "display system summary"
        pass
    def do_kerninfo(self, line):
        "display kernel loop and PPS statistics"
        pass
    def do_sysstats(self, line):
        "display system uptime and packet counts"
        pass
    def do_monstats(self, line):
        "display monitor (mrulist) counters and limits"
        pass
    def do_authinfo(self, line):
        "display symmetric authentication counters"
        pass
    def do_iostats(self, line):
        "display network input and output counters"
        pass
    def do_timerstats(self, line):
        "display interval timer counters"
        pass

# Default values we use.
DEFHOST 	= "localhost"	# default host name

# Requests are automatically retried once, so total timeout with no
# response is a bit over 2 * DEFTIMEOUT, or 10 seconds.  At the other
# extreme, a request eliciting 32 packets of responses each for some
# reason nearly DEFSTIMEOUT seconds after the prior in that series,
# with a single packet dropped, would take around 32 * DEFSTIMEOUT, or
# 93 seconds to fail each of two times, or 186 seconds.
# Some commands involve a series of requests, such as "peers" and
# "mrulist", so the cumulative timeouts are even longer for those. 
DEFDELAY	= 0x51EB852	# 20 milliseconds, l_fp fraction 
MAXVARLEN	= 256		# maximum length of a variable name 
MAXVALLEN	= 2048		# maximum length of a variable value 
MAXOUTLINE	= 72		# maximum length of an output line 
SCREENWIDTH	= 76		# nominal screen width in columns 

# Macro definitions we use
def ISSPACE(c):	return ((c) == ' ' or (c) == '\t')
def ISEOL(c):	return ((c) == '\n' or (c) == '\r' or (c) == '\0')

#
# main - parse arguments and handle options
# 

usage = '''
USAGE: ntpq [-46dphinOV] [-c str] [-D lvl] [ host ...]
  Flg Arg Option-Name    Description
   -4 no  ipv4           Force IPv4 DNS name resolution
				- prohibits the option 'ipv6'
   -6 no  ipv6           Force IPv6 DNS name resolution
				- prohibits the option 'ipv4'
   -c Str command        run a command and exit
				- may appear multiple times
   -d no  debug-level    Increase output debug message level
				- may appear multiple times
   -D Str set-debug-level Set the output debug message level
				- may appear multiple times
   -h no  help           Print a usage message.
   -p no  peers          Print a list of the peers
				- prohibits the option 'interactive'
   -i no  interactive    Force ntpq to operate in interactive mode
				- prohibits these options:
				command
				peers
   -n no  numeric        numeric host addresses
   -O no  old-rv         Always output status line with readvar
   -V opt version        Output version information and exit
   -w no  wide           enable wide display of addresses
'''

if __name__ == '__main__':
    #delay_time.l_ui = 0
    #delay_time.l_uf = DEFDELAY

    #init_lib()	# sets up ipv4_works, ipv6_works 
    #ssl_applink()
    #init_auth()

    try:
        (options, arguments) = getopt.getopt(sys.argv[1:],
                                             "46c:dD:hinOpVw",
                                             ["ipv4","ipv6","command",
                                              "debug","set-debug-level",
                                              "help", "interactive", "numeric",
                                              "old-rv","peers","version",
                                              "wide"])
    except getopt.GetoptError as e:
        print(e)
        raise SystemExit(1)
    progname = sys.argv[0]

    session = ntpq_session()
    interpreter = ntpq_interpreter(session)

    for (switch, val) in options:
        if switch in ("-4", "--ipv4"):
            interpreter.ai_family = socket.AF_INET
        elif switch in ("-6", "--ipv6"):
            interpreter.ai_family = socket.AF_INET6
        elif switch in ("-c", "--command"):
            interpreter.ccmds.append(val)
        elif switch in ("-d", "--debug"):
            interpreter.debug += 1
        elif switch in ("-D", "--set-debug-level"):
            interpreter.debug = int(val)
        elif switch in ("-h", "--help"):
            print(usage)
            raise SystemExit(0)
        elif switch in ("-i", "--interactive"):
            interpreter.interactive = True
        elif switch in ("-n", "--numeric"):
            interpreter.showhostnames = False
        elif switch in ("-O", "--old-rv"):
            interpreter.old_rv = True
        elif switch in ("-p", "--peers"):
            interpreter.ccmds.append("peers")
        elif switch in ("-V", "--version"):
            print("ntpq %s\n" % version)
            raise SystemExit(0)
        elif switch in ("-w", "--wide"):
            interpreter.wideremote = True
        else:
            sys.stderr.write("Unknown command line switch or missing argument.\n")
            sys.stderr.write(usage)
            raise SystemExit(1)

    if interpreter.interactive and len(interpreter.ccmds) > 0:
        sys.stderr.write("%s: invalid option combination.\n" % progname)
        raise SystemExit(1)

    if len(arguments) == 0:
        interpreter.chosts.append((DEFHOST, session.ai_family))
    else:
        for token in arguments:
            if token.startswith("-"):
                if '4' == token[1]:
                    session.ai_family = socket.AF_INET
                elif '6' == token[1]:
                    session.ai_family = socket.AF_INET6
            else:
                interpreter.chosts.append((token, session.ai_family))

    if len(interpreter.ccmds) == 0 and not interpreter.interactive and os.isatty(0) and os.isatty(1):
        interpreter.interactive = True

    try:
        if len(interpreter.ccmds) == 0:
            session.openhost(*interpreter.chosts[0])
            interpreter.cmdloop()
        else:
            for ihost in interpreter.chosts:
                if session.openhost(*ihost):
                    for cmd in interpreter.ccmds:
                        interpreter.onecmd(cmd)
                    session.close()
        raise SystemExit(0)
    except KeyboardInterrupt:
        sys.stdout.write("\n")
# end
