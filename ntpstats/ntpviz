#!/usr/bin/env python
# coding: utf-8
"""\
ntpviz - logfile visualizer for NTP log files

Usage: ntpviz [-d statsdir] [-g] [-n name] [-p days]
              [-s starttime]  [-e endtime]
              [--local-offset | --local-error | --local-jitter
                | --local-stability | --local-offset-histogram
                | --peer-offsets=hosts | --all-peer-offsets
                | --peer-jitters=hosts | --all-peer-jitters
                | --local-temps
                | --local-gps
                | --local-offset-multiplot]
              [-o outdir]
              [-D N]

See the manual page for details.

Python by ESR, concept and GNUPLOT code by Dan Drown.
"""
#SPDX-License-Identifier: BSD-2-Clause
from __future__ import print_function, division

import argparse
import atexit, binascii, collections, os, socket, sys, time
from ntp.statfiles import *

def print_profile():
    """called by atexit() on normal exit to print profile data"""
    pr.disable()
    pr.print_stats('tottime')
    pr.print_stats('cumtime')

# standard deviation functions
# use this until we can guarantee Python 3.4 and the statistics module
# http://stackoverflow.com/questions/15389768/standard-deviation-of-a-list#21505523

def mean(data):
    """Return the sample arithmetic mean of data."""
    n = len(data)
    if n < 1:
        raise ValueError('mean requires at least one data point')
    return sum(data)/n # in Python 2 use sum(data)/float(n)

def _ss(data, mu=None):
    """Return sum of square deviations of sequence data."""
    if mu is None:
        c = mean(data)
    else:
        c = mu
    ss = sum((x-c)**2 for x in data)
    return ss

# fixme, need to handle mu=mean
def pstdev(data, mu=None):
    """Calculates the population standard deviation."""
    n = len(data)
    if n < 2:
        # variance requires at least two data points
        return 0
    ss = _ss(data, mu)
    pvar = ss/n # the population variance
    return pvar**0.5

# end standard deviation functions

# class for calced values
class VizStats(NTPStats):
    percs       = {}          # dictionary of percentages
    title       = ''          # title
    unit        = 's'         # display units: s, ppm, etc.
    multiplier  = 1
    pmax        = 0     # 100%, can't use max, reserved word
    ninetynine  = 0     #  99%
    ninetyfive  = 0     #  90%
    fifty       = 0     #  50%
    five        = 0     #  5%
    one         = 0     #  1%
    pmin        = 0     #  0%, can't use min, reserved word

    nf_m_f      = 0     # 95% - 5%
    nn_m_o      = 0     # 99% - 1%

    mu          = 0     # arithmetic mean
    pstd        = 0     # population standard distribution, one sigma

    stats_html  = ''

    def __init__( self, values, title, freq=0 ):

        values.sort()
        self.percs = self.percentiles( (100, 99, 95, 50, 5, 1, 0), values)

        # find the target for autoranging
        # keep 99% and 5% under 999 in selected units
        # but do not let 100% and 1% go over 5000 in selected units
        target = max(self.percs[99], -self.percs[1], self.percs[100]/5,
                     -self.percs[0]/5)
        if 1 <= target:
            self.multiplier = 1
            if freq:
                # go to ppm
                self.unit = "ppm"
            else:
                # go to seconds
                self.unit = "s"

        elif 1e-3 <= target:
            self.multiplier = 1e3
            if freq:
                # go to ppb
                self.unit = "ppb"
            else:
                # go to millisec
                self.unit = "ms"

        elif 1e-6 <= target:
            self.multiplier = 1e6
            if freq:
                self.unit = "10e-12"
            else:
                # go to microsec
                self.unit = "µs"

        else:
            self.multiplier = 1e9
            if freq:
                self.unit = "10e-15"
            else:
                # go to nanosec
                self.unit = "ns"

        self.percs.update({k: v * self.multiplier
                     for k, v in list(self.percs.items())})

        self.title       = title
        self.pmax        = self.percs[100]
        self.ninetynine  = self.percs[99]
        self.ninetyfive  = self.percs[95]
        self.fifty       = self.percs[50]
        self.five        = self.percs[5]
        self.one         = self.percs[1]
        self.pmin        = self.percs[0]

        self.nf_m_f     = self.ninetyfive - self.five
        self.nn_m_o     = self.ninetynine - self.one

        self.mu = mean( values )
        self.pstd = pstdev( values, mu=self.mu ) * self.multiplier
        self.mu *= self.multiplier
        self.stats_html =  ''
        if '' != title:
            self.stats_html =  "<h4>%(title)s</h4>\n" % locals()
        self.stats_html +=  """\
<p style="margin-left:20px;">Percentiles: Max: %(pmax)s, &nbsp;
 99%%: %(ninetynine)s,&nbsp;&nbsp;
 95%%: %(ninetyfive).3f,&nbsp;&nbsp;
 50%%: %(fifty).3f,&nbsp;&nbsp;
 5%%: %(five).3f,&nbsp;&nbsp;
 1%%: %(one).3f,&nbsp;&nbsp;
 Min: %(pmin).3f  %(unit)s<br>
Ranges: 99%% - 1%% = %(nn_m_o).3f %(unit)s, &nbsp;
 95%% - 5%% = %(nf_m_f).3f %(unit)s<br>
Deviation: Mean = %(mu).3f %(unit)s,  &nbsp;
1σ = %(pstd).3f %(unit)s</p>
""" % self.__dict__


# end calc things now

# RMS frequency jitter - Deviation from a root-mean-square linear approximation?
# Investigate.

def gnuplot(template, outfile=None):
    "Run a specified GNUPLOT program."
    if not len( template ):
        # silently ignore empty plots
        return ''
    if outfile is None:
        out = None
    else:
        out = open(outfile, "w")
    # shell=True is a security hazard
    # would be great to capture stderr, but the Python doc says
    # that can lead to deadlock on large stderr output.  gnuplot
    # can output a lot to stderr...
    proc = subprocess.Popen("gnuplot",
                            shell=False, bufsize=4096,
                            stdin=subprocess.PIPE, stdout=out)
    v = sys.version_info
    if 3 <= v[0]:
        # next line works in Python 3, not Python 2
        proc.stdin.write(template.encode('ascii','ignore'))
    else:
        # next line works in Python 2, not Python 3
        proc.stdin.write(template)
    proc.stdin.close()
    return proc.wait()

def plotwrap(imagename, image, outfile):
    "Generate an image and index section for a GNUPLOT section."
    gnuplot(image, os.path.join(outdir, imagename + ".png"))
    div_name = imagename.replace('-', ' ')
    div = '''\
<div>
  <h3>%s</h3>
  <img src='%s.png' alt='%s plot'>
</div>
''' % (div_name, imagename.replace(':', '%3A'), div_name)
    outfile.write(div)

class NTPViz(NTPStats):
    "Class for visualizing statistics from a single server."
    # Python takes single quotes here. Since no % substitution
    Common = """\
set terminal png size 900,600
set xdata time
set grid
set xlabel "Time (dd-hh:mm)"
set format x "%d-%H:%M"
set timefmt "%s"
set xtic rotate by -45 scale 0
set lmargin 12
set rmargin 12
"""

    def __init__(self, statsdir,
                 sitename=None, period=None, starttime=None, endtime=None):
        NTPStats.__init__(self, statsdir=statsdir, sitename=sitename,
                          period=period, starttime=starttime, endtime=endtime)

    def local_offset_gnuplot(self):
        "Generate GNUPLOT code graphing local clock loop statistics"
        if not len( self.loopstats):
            sys.stderr.write("ntpviz: WARNING: no loopstats to graph\n")
            return ''
        sitename = self.sitename

        # compute clock offset
        values = [float(line.split()[1]) for line in self.loopstats]
        stats = VizStats( values, "Local Clock Time Offset")
        unit = stats.unit
        multiplier = stats.multiplier

        # compute frequency offset
        values_f = [float(line.split()[2]) for line in self.loopstats]
        stats_f = VizStats(values_f, "Local Clock Frequency Offset", freq=1)
        unit_f = stats_f.unit
        multiplier_f = stats_f.multiplier

        plot_template = NTPViz.Common + """\
set title "%(sitename)s: Local Clock Time/Frequency Offsets"
set ytics format "%%1.1f %(unit)s" nomirror textcolor rgb '#0060ad'
set y2tics format "%%2.1f %(unit_f)s" nomirror textcolor rgb '#dd181f'
set key bottom right box
set style line 1 lc rgb '#0060ad' lt 1 lw 1 pt 7 ps 0   # --- blue
set style line 2 lc rgb '#dd181f' lt 1 lw 1 pt 5 ps 0   # --- red
plot \
 "-" using 1:($2*%(multiplier)s) title "clock offset %(unit)s" with linespoints ls 1, \
 "-" using 1:($3*%(multiplier_f)s) title "frequency offset %(unit_f)s" with linespoints ls 2 axis x1y2
""" % locals()

        exp = """\
<p>The time and frequency offsets between the ntpd calculated time
and the local system clock.  Showing frequency offset (red, in parts
per million, scale on right) and the time offset (blue, in μs, scale
on left).  Quick changes in time offset will lead to larger frequency
offsets.</p>

<p>These are fields 3 (time) and 4 (frequency) from the loopstats log
file.</p>

"""

        ret = {}
        ret['html'] = stats.stats_html + stats_f.stats_html + exp
        ret['percs'] = stats.percs
        ret['title'] = "Local Clock Time/Frequency Offsets"
        ret['plot'] = plot_template + self.dump("loopstats") + "e\n" \
             + self.dump("loopstats") + "e\n"
        return ret

    def local_temps_gnuplot(self):
        "Generate GNUPLOT code graphing local temperature statistics"
        sitename = self.sitename
        tempsmap = self.tempssplit()
        tempslist = list(tempsmap.keys())
        tempslist.sort()

        if not len( tempsmap) or not len( tempslist):
            sys.stderr.write("ntpviz: WARNING: no temps to graph\n")
            return ''

        percs = ()
        temps_data = ()
        plot_data = ""
        for key in tempslist:
            plot_data += "\n".join(tempsmap[key]) + "\ne\n"

        plot_template = NTPViz.Common + """\
set title "%(sitename)s: Local Temparatures"
set ytics format "%%1.1f °C" nomirror textcolor rgb '#0060ad'
set style line 1 lc rgb '#0060ad' lt 1 lw 1 pt 7 ps 0   # --- blue
plot \\
""" % locals()

        for key in tempslist:
            plot_template += "'-' using 1:3 title '%(key)s' with line, \\\n" \
                 % locals()

        # strip the trailing ", \n"
        plot_template = plot_template[:-4] + "\n"
        exp = """\
<p>Local temperatures.  These will be site specific depending on what
temperature sensors you have and collect data from.  Temperature
changes change the local clock crystal frequency and stability.  Crystals
oscillate faster when warmer. This the single most important
component of frequency drift.</p>
<p>The Local Termperatures are from field 3 from the tempstats log file.</p>
"""
        ret = {'html' : exp, 'percs' : percs }
        ret['title'] = "Local Temperatures"
        ret['plot'] = plot_template + plot_data
        return ret

    def local_gps_gnuplot(self):
        "Generate GNUPLOT code graphing local gps statistics"
        sitename = self.sitename
        gpsmap = self.gpssplit()
        gpslist = list(gpsmap.keys())
        gpslist.sort()

        if not len( gpsmap) or not len( gpslist):
            if 1 <= args.debug_level:
                sys.stderr.write("ntpviz: INFO: no gps data to graph\n")
            return ''

        percs = ()
        gps_data = ()
        plot_data = ""
        for key in gpslist:
            d = "\n".join(gpsmap[key])
            plot_data += d + "\ne\n" + d + "\ne\n"
        # remove trailing "e\n"
        plot_data = plot_data[:-2]

        plot_template = NTPViz.Common + """\
set title "%(sitename)s: Local GPS
set ytics format "%%1.3f tdop" nomirror textcolor rgb '#0060ad'
set y2tics format "%%2.0f nSat"  nomirror textcolor rgb '#dd181f'
set style line 1 lc rgb '#0060ad' lt 1 lw 1 pt 7 ps 0   # --- blue
set style line 2 lc rgb '#dd181f' lt 1 lw 1 pt 5 ps 0   # --- red
plot \\
""" % locals()

        for key in gpslist:
            plot_template += """\
'-' using 1:3 title '%(key)s tdop' with line, \\
'-' using 1:4 title '%(key)s nSat' with line axis x1y2, \\
""" % locals()

        # strip the trailing ", \\n"
        plot_template = plot_template[:-4] + "\n"
        exp = """\
<p>Local GPS.  The Time Dilution of Precision (tdop) is plotted in blue.
The number of visible satellites (nSat) is plotted in red.</p>
<p>tdop is field 3, and nSats is field 4, from the gpsd log file.  The
gpsd log file is created by the gps-log.py program.</p>
"""
        ret = {'html' : exp, 'percs' : percs }
        ret['title'] = "Local GPS"
        ret['plot'] = plot_template + plot_data
        return ret

    def local_error_gnuplot(self):
        "Plot the local clock frequency error."
        if not len( self.loopstats):
            sys.stderr.write("ntpviz: WARNING: no loopstats to graph\n")
            return ''
        sitename = self.sitename
        # grab and sort the values, no need for the timestamp, etc.

        # compute freqency offset
        values = [float(line.split()[2]) for line in self.loopstats]
        stats = VizStats( values, "Local Clock Frequency Offset", freq=1, )
        unit = stats.unit
        multiplier = stats.multiplier

        ninetynine  = stats.ninetynine
        ninetyfive  = stats.ninetyfive
        five        = stats.five
        one         = stats.one

        plot_template = NTPViz.Common + """\
set title "%(sitename)s: Local Clock Frequency Offset"
set ytics format "%%1.1f %(unit)s" nomirror
set key bottom right box
set style line 1 lc rgb '#0060ad' lt 1 lw 1 pt 7 ps 0   # --- blue
set style line 2 lc rgb '#dd181f' lt 1 lw 1 pt 5 ps 0   # --- red
plot \
 "-" using 1:($3 * %(multiplier)s) title "local clock error" with linespoints ls 2, \
 %(ninetynine)s title "99th percentile", \
 %(ninetyfive)s title "95th percentile", \
 %(five)s title "5th percentile", \
 %(one)s title "1st percentile"
""" % locals()

        exp = """\
<p>This shows the frequency offset of the local clock (aka drift).  The
graph includes percentile data to show how much the frequency changes
over a longer period of time.  The majority of this change should come
from temperature changes (ex: HVAC, the weather, CPU usage causing local
heating).</p>

<p>Smaller changes are better.  An ideal result would be a horizontal
line at 0ppm.  Expected values of 99%-1% percentiles: 0.4ppm</p>

<p>The Frequency Offset comes from field 4 of the loopstats log file.</p>
"""
        ret = {'html' : stats.stats_html + exp, 'percs' : stats.percs }
        ret['title'] = "Local Clock Frequency Offset"
        ret['plot'] = plot_template + self.dump("loopstats") + "e\n"
        return ret

    def loopstats_gnuplot(self, fld, title, legend, freq):
        "Generate GNUPLOT code of a given loopstats field"
        if not len( self.loopstats):
            sys.stderr.write("ntpviz: WARNING: no loopstats to graph\n")
            return ''

        sitename   = self.sitename
        # grab and process the values
        values = [float(line.split()[fld - 1]) for line in self.loopstats]
        stats = VizStats( values, title, freq=freq )
        unit = stats.unit
        multiplier = stats.multiplier

        ninetynine  = stats.ninetynine
        ninetyfive  = stats.ninetyfive
        five        = stats.five
        one         = stats.one

        if freq:
            exp = """\
<p>This shows the RMS Frequency Jitter (aka wander) of the local
clock's frequency.  In other words, how fast the local clock changes
freqency.</p>

<p>Lower is better.  An ideal clock would be a horizontal line at
0ppm.</p>

<p> RMS Frequency Jitter is field 6 in the loopstats log file.</p>
"""
        else:
            exp = """\
<p>This shows the RMS Jitter of the local clock offset.  In other words,
how fast the local clock offset is changing.</p>

<p>Lower is better.  An ideal system would be a horizontal line at 0μs.</p>

<p>RMS jitter is field 5 in the loopstats log file.</p>
"""


        plot_template = NTPViz.Common + """\
set title "%(sitename)s: %(title)s"
set ytics format "%%1.1f %(unit)s" nomirror
set key top right box
set style line 1 lc rgb '#0060ad' lt 1 lw 1 pt 7 ps 0   # --- blue
set style line 2 lc rgb '#dd181f' lt 1 lw 1 pt 5 ps 0   # --- red
plot \
 "-" using 1:($%(fld)d*%(multiplier)s) title "%(legend)s" with linespoints ls 1, \
 %(ninetynine)s title "99th percentile", \
 %(ninetyfive)s title "95th percentile", \
 %(five)s title "5th percentile", \
 %(one)s title "1st percentile"
""" % locals()

        ret = {'html' : stats.stats_html + exp, 'percs' : stats.percs,
               'title' : title }
        ret['plot'] = plot_template + self.dump("loopstats") + "e\n"
        return ret

    def local_offset_jitter_gnuplot(self):
        "Generate GNUPLOT code of local clock loop standard deviation"
        return self.loopstats_gnuplot(4, "Local RMS Time Jitter", "Jitter", 0)

    def local_offset_stability_gnuplot(self):
        "Generate GNUPLOT code graphing local clock stability"
        return self.loopstats_gnuplot(5, "Local RMS Frequency Jitter",
                                      "Stability", 1)

    def peerstats_gnuplot(self, peerlist, fld, title, type):
        "Plot a specified field from peerstats."
        sitename = self.sitename
        peerdict = self.peersplit()
        if not peerlist:
            peerlist = list(peerdict.keys())
        if not len( peerlist):
            sys.stderr.write("ntpviz: WARNING: no peer data to graph\n")
            return ''
        peerlist.sort() # For stability of output
        peer_data = ()
        plot_data = ""
        for key in peerlist:
            # Trickiness - we allow peerlist elements to be DNS names.
            # The socket.gethostbyname() call maps DNS names to IP addresses,
            # passing through literal IPv4 addresses unaltered.  However,
            # it barfs on either literal IPv6 addresses or refclock names.
            try:
                ip = socket.gethostbyname(key)
            except:
                # ignore it
                ip = key

            if ip in peerdict:
                plot_data += "\n".join(peerdict[ip]) + "\ne\n"
            else:
                sys.stderr.write("ntpviz: ERROR: No such peer as %s" % key)
                raise SystemExit(1)
        # remove trailing "e\n"
        plot_data = plot_data[:-2]

        unit = "μs"
        multiplier = 1e6
        rtt = 0
        percentages = ""
        percs = []
        if len(peerlist) == 1:
            # only one peer
            title += ": "+ peerlist[0]
            # grab and sort the values, no need for the timestamp, etc.
            values = [float(line.split()[fld - 1]) for line in peerdict[ip]]

            stats = VizStats( values, title)
            unit        = stats.unit
            multiplier  = stats.multiplier
            persc       = stats.percs

            ninetynine  = stats.ninetynine
            ninetyfive  = stats.ninetyfive
            fifty       = stats.fifty
            five        = stats.five
            one         = stats.one

            percentages = " %(fifty)s title '50th percentile', " \
                           % locals()

            exp = stats.stats_html

            if "offset" == type:
                # doing offset, not jitter
                rtt = 1
                if "127.127." == peerlist[0][:8]:
                    # don't do rtt for reclocks
                    rtt = 0
                    title = "Refclock Offset " + str(peerlist[0])
                    exp += """\
<p>This shows the offset of a local refclock in %(unit)s.  This is
useful to see how the measured offset is behaving.</p>

<p>Closer to 0s is better.  An ideal system would be a horizontal line
at 0s. Typical 90%% ranges may be: local serial GPS 200 ms; local PPS
20µs</p>

<p>Clock Offset is field 5 in the peerstats log file.</p>
""" %  locals()
                else:
                    title = "Peer Offset " + str(peerlist[0])
                    exp += """\
<p>This shows the offset of a peer or server in seconds.  This is
useful to see how the measured offset is behaving.</p>

<p>The chart also plots offset±rtt.  Where rtt is the round trip time
to the remote.  NTP can not really know the offset of a remote chimer,
NTP computes it by subtracting rtt/2 from the offset.  Plotting the
offset±rtt reverses this calculation to more easily see the effects of
rtt changes.</p>

<p>Closer to 0s is better.  An ideal system would be a horizontal line
at 0s. Typical 90% ranges may be: local LAN peer 80µs; 90% ranges for
WAN servers may be 4ms and much larger. </p>

<p>Clock Offset is field 5 in the peerstats log file.</p>
"""

            else:
                # doing jitter, not offset
                if "127.127." == peerlist[0][:8]:
                    title = "Refclock RMS Jitter " + str(peerlist[0])
                    exp += """\
<p>This shows the RMS Jitter of a local refclock.  Jitter is the
current estimated dispersion; the variation in offset between samples.</p>

<p>Closer to 0s is better.  An ideal system would be a horizontal
line at 0s.</p>

<p>RMS Jitter is field 8 in the peerstats log file.</p>
"""
                else:
                    title = "Peer Jitter " + str(peerlist[0])
                    exp += """\
<p>This shows the RMS Jitter of a remote peer or server.  Jitter is
the current estimated dispersion; the variation in offset between
samples.</p>

<p>Closer to 0s is better.  An ideal system would be a horizontal line
at 0s.</p>

<p>RMS Jitter is field 8 in the peerstats log file.</p>
"""

        else:
            # many peers
            title += "s"
            # grab and sort the values, no need for the timestamp, etc.
            values = [float(line.split()[fld - 1]) for line in self.peerstats]

            stats = VizStats( values, title )
            unit        = stats.unit
            multiplier  = stats.multiplier
            persc       = stats.percs

            exp = stats.stats_html
            if "offset" == type:
                title = "Peer Offsets"
                exp += """\
<p>This shows the offset of all refclocks, peers and servers in
%(unit)s.  This can be useful to see if offset changes are happening in
a single clock or all clocks together.</p>

<p>Clock Offset is field 5 in the peerstats log file.</p>
""" % locals()
            else:
                title = "Peer Jitters"
                exp += """\
<p>This shows the RMS Jitter of all refclocks, peers and servers.
Jitter is the current estimated dispersion; the variation in offset
between samples.</p>

<p>Closer to 0s is better.  An ideal system would be a horizontal line
at 0s.</p>

<p>RMS Jitter is field 8 in the peerstats log file.</p>
"""

        if 6 >= len(peerlist):
            set_key = "set key top right box"
        else:
            # too many keys to show
            set_key = "set key off"

        plot_template = NTPViz.Common + """\
set title "%(sitename)s: %(title)s"
set ylabel ""
set ytics format "%%1.1f %(unit)s" nomirror
%(set_key)s
plot \
""" % locals()
        plot_template += percentages
        for key in peerlist:
            label = self.ip_label(key)
            plot_template += "'-' using 1:($%(fld)s*%(multiplier)s) title '%(label)s' with line, \\\n" \
                 % locals()

        if 1 == rtt:
            plot_template += """\
'-' using 1:(($4+$5/2)*%(multiplier)s) title 'offset+rtt/2' with line, \\
'-' using 1:(($4-$5/2)*%(multiplier)s) title 'offset-rtt/2' with line
""" % locals()
            plot_template += plot_data + "\ne\n" + plot_data + "\ne\n"
        else:
            # strip the trailing ", \n"
            plot_template = plot_template[:-4] + "\n"

        ret = {'html' : exp, 'percs' : percs, 'title' : title }
        ret['plot'] = plot_template + plot_data + "e\n"
        return ret

    def peer_offsets_gnuplot(self, peerlist=None):
        return self.peerstats_gnuplot(peerlist, 4, "Peer Clock Offset", "offset")

    def peer_jitters_gnuplot(self, peerlist=None):
        return self.peerstats_gnuplot(peerlist, 7, "Peer Clock Jitter", "jitter")

    def local_offset_histogram_gnuplot(self):
        "Plot a histogram of clock offset values from loopstats."
        if not len( self.loopstats):
            sys.stderr.write("ntpviz: WARNING: no loopstats to graph\n")
            return ''
        sitename = self.sitename

        # TODO normalize to 0 to 100

        # grab and sort the values, no need for the timestamp, etc.
        values = [float(line.split()[1]) for line in self.loopstats]
        stats = VizStats( values, 'Local Clock Offset' )
        unit        = stats.unit
        multiplier  = stats.multiplier

        ninetynine  = stats.ninetynine
        ninetyfive  = stats.ninetyfive
        fifty       = stats.fifty
        five        = stats.five
        one         = stats.one

        # fixme, should piggy back on unit
        rnd1 = 7        # round to 100 ns boxes
        boxwidth = 1e-7
        if 1e-6 > stats.percs[99] and -1e-6 < stats.percs[1]:
            # go to nanosec
            rnd1 = 9        # round to 1 ns boxes
            boxwidth = 1e-9

        cnt = collections.Counter()
        for value in values:
            # put into buckets
            # for a +/- 50 microSec range that is 1,000 buckets to plot
            cnt[ round( float(value), rnd1)] += 1

        # plus/minus of one sigma range
        m1sigma = stats.mu - stats.pstd
        p1sigma = stats.mu + stats.pstd

        plot_template = '''\
set terminal png size 900,600
set grid
set boxwidth %(boxwidth)s
set xtic rotate by -45 scale 0
set title "%(sitename)s: Local Clock Time Offset Histogram"
set xtics format "%%1.1f %(unit)s" nomirror
set style arrow 1 nohead
set arrow from %(m1sigma)s,graph 0 to %(m1sigma)s,graph 0.90 as 1
set style arrow 2 nohead
set arrow from %(p1sigma)s,graph 0 to %(p1sigma)s,graph 0.90 as 2
set style arrow 3 nohead
set arrow from %(ninetynine)s,graph 0 to %(ninetynine)s,graph 0.30 as 3
set style arrow 4 nohead
set arrow from %(ninetyfive)s,graph 0 to %(ninetyfive)s,graph 0.45 as 4
set style arrow 5 nohead
set arrow from %(five)s,graph 0 to %(five)s,graph 0.45 as 5
set style arrow 6 nohead
set arrow from %(one)s,graph 0 to %(one)s,graph 0.30 as 6
set key off
set lmargin 12
set rmargin 12
set style fill solid 0.5
set label 1 "-1σ" at %(m1sigma)s, graph 0.96  left front offset -1,-1
set label 2 "+1σ" at %(p1sigma)s, graph 0.96  left front offset -1,-1
set label 3 "99%%" at %(ninetynine)s, graph 0.35  left front offset -1,-1
set label 4 "95%%" at %(ninetyfive)s, graph 0.50  left front offset -1,-1
set label 5 "1%%" at %(one)s, graph 0.35  left front offset -1,-1
set label 6 "5%%" at %(five)s, graph 0.50  left front offset -1,-1
plot \
 "-" using ($1 * %(multiplier)s):2 title "histogram" with boxes
''' % locals()
        vals = list(cnt.keys())
        vals.sort()
        histogram_data = ["%s %s\n" % (val, cnt[val]) for val in vals]

        exp = """\
<p>This shows the clock offsets of the local clock as a histogram.</p>

<p>The Local Clock Offset is field 3 from the loopstats log file.</p>
""" % locals()
        ret = {'html' : stats.stats_html + exp, 'percs' : stats.percs}
        ret['title'] = "Local Clock Time Offset Histogram"
        ret['plot'] = plot_template + "".join(histogram_data) + "e\n"
        return ret

# Multiplotting can't live inside NTPViz because it consumes a list
# of such objects, not a single one.

def local_offset_multiplot(statlist):
    "Plot comparative local offsets for a list of NTPViz objects."

    plot = NTPViz.Common + '''\
set title "Multiplot Local Clock Offsets"
set ytics format "%1.2f μs" nomirror textcolor rgb "#0060ad"
set key bottom right box
plot \\
'''
    # FIXME: We probably need to be more flexible about computing the plot label
    sitenames = [os.path.basename(os.path.dirname(d)) for d in args.statsdirs]
    for (i, stats) in enumerate(statlist):
        plot += '"-" using 1:($2*1000000) title "%s clock offset μs" with linespoints, \\\n' % (sitenames[i])
    plot = plot[:-4] + "\n"
    for stats in statlist:
        plot += stats.dump("loopstats") + "e\n"

    ret = {'html' : '', 'percs' : '' }
    ret['title'] = "Multiplot"
    ret['plot'] = plot
    return ret

# here is how to create the base64 from an image file:
# with open("path/to/file.png", "rb") as f:
#    data = f.read()
#    print data.encode("base64")
#
ntpsec_logo = """
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
"""

ntpsec_ico = """\
AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAQAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/
AAAA/wAAAP8AAAD/AAAAAAAAAP+fn59gn5+fYJ+fn2Cfn59gn5+fYJ+fn2Cfn59gn5+fYJ+fn2Cf
n59gn5+fYJ+fn2B/f39/AAAA/wAAAAAAAAAAAAAA/5+fn2Cfn59gn5+fYJ+fn2Cfn59gn5+fYJ+f
n2Cfn59gn5+fYJ+fn2Cfn59gAAAA/wAAAAAAAAAAAAAAAAAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA
/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAAAAAAAAAAAAAAAAAAAAAAA/5+fn2Cfn59g
n5+fYJ+fn2Cfn59gn5+fYJ+fn2Cfn59gn5+fYAAAAP8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP+f
n59gn5+fYAAAAP8AAAD/AAAA/wAAAP8AAAD/n5+fYJ+fn2AAAAD/AAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAD/n5+fYAAAAP8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP+fn59gAAAA/wAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAA/5+fn2AAAAD/AAAAAAAAAAAAAAD/AAAA/01NTWAAAAD/n5+fYAAAAP8AAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAP+fn59gAAAA/wAAAAAAAAAAAAAA/wAAAAAAAAAAAAAA/5+fn2AA
AAD/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/n5+fYAAAAP8AAAAAAAAAAE1NTWAAAAAAAAAAAAAA
AP+fn59gAAAA/wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/5+fn2Cfn59gAAAA/wAAAP8AAAD/AAAA
/wAAAP+fn59gn5+fYAAAAP8AAAAAAAAAAAAAAAAAAAAAAAAAAAEBAf+fn59gn5+fYJ+fn2Cfn59g
n5+fYJ+fn2Cfn59gn5+fYJ+fn2AAAAD/AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/AAAA/wAAAP8A
AAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAAAAAAAAAAAAAAAAAAAAAAD/AAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/AAAAAAAAAAAAAAAAAAAA
/wAAAAAAAAD/AAAA/wAAAP8AAAAAAAAAAAAAAAAAAAD/AAAA/wAAAP8AAAAAAAAA/wAAAAAAAAAA
AAAAAAAAAP8AAAD/AAAA/wAAAAAAAAD/AAAA/wAAAP8AAAD/AAAA/wAAAAAAAAD/AAAA/wAAAP8A
AAAAgAAAAL/+AADf/QAAwAEAAO/7AADsGwAA6+sAAOsrAADrawAA6+sAAOwbAADv+wAA4AMAAN/9
AADRxQAAxBEAAA==
"""

if __name__ == '__main__':

    parser = argparse.ArgumentParser(description="ntpd stats visualizer",
                fromfile_prefix_chars='@',
                epilog = """
You can place command line options in a file, one per line.

See the manual page for details.

Python by ESR, concept and GNUPLOT code by Dan Drown.
""")
    group = parser.add_mutually_exclusive_group()

    parser.add_argument('-g', '--generate',
                default=False,
                action="store_true",
                dest='generate',
                help="Run plot through gnuplot to make png")
    parser.add_argument('-e', '--endtime',
                default=None,
                dest='endtime',
                help="End time in POSIX (seconds) or ISO8601",
                type=str)
    parser.add_argument('-s', '--starttime',
                default=None,
                dest='starttime',
                help="Start time in POSIX (seconds) or ISO8601",
                type=str)
    parser.add_argument('-n', '--name',
                default=socket.getfqdn(),
                dest='sitename',
                help="sitename (title)",
                type=str)
    parser.add_argument('-o', '--outdir',
                default = "ntpgraphs",
                dest='outdir',
                help="output directory",
                type=str)
    parser.add_argument('-d', '--datadir',
                default = "/var/log/ntpstats",
                dest='statsdirs',
                help="one or more logfile directories to read",
                type=str)
    parser.add_argument('-p', '--period',
                default = 7,    # default to 7 days
                dest='period',
                help="period in days to graph (float)",
                type=float)
    group.add_argument( '--all-peer-jitters',
                default = False,
                action="store_true",
                dest='show_peer_jitters',
                help="Plot all peer jitters")
    group.add_argument( '--peer-jitters',
                default = '',
                dest='peer_jitters',
                help="Plot peer jitters.  Comma separated host list.",
                type=str)
    group.add_argument( '--all-peer-offsets',
                default = False,
                action="store_true",
                dest='show_peer_offsets',
                help="Plot all peer offsets")
    group.add_argument( '--peer-offsets',
                default = '',
                dest='peer_offsets',
                help="Plot peer offsets.  Comma separated host list.",
                type=str)
    group.add_argument( '--local-error',
                default=False,
                action="store_true",
                dest='show_local_error',
                help="Plot clock time and clock frequency offsets")
    group.add_argument( '--local-gps',
                default = False,
                action="store_true",
                dest='show_gps',
                help="Plot gpsd tdop and nSats")
    group.add_argument( '--local-jitter',
                default=False,
                action="store_true",
                dest='show_local_jitter',
                help="Plot clock time jitter")
    group.add_argument( '--local-offset',
                default=False,
                action="store_true",
                dest='show_local_offset',
                help="Plot Clock frequency offset")
    group.add_argument( '--local-offset-histogram',
                default=False,
                action="store_true",
                dest='show_local_offset_histogram',
                help="Plot histogram of loopstats time offsets")
    group.add_argument( '--local-offset-multiplot',
                default = False,
                action="store_true",
                dest='show_local_offset_multiplot',
                help="Plot comparative local offsets for multiple directories")
    group.add_argument( '--local-stability',
                default=False,
                action="store_true",
                dest='show_local_stability',
                help="Plot RMS frequency-jitter")
    group.add_argument( '--local-temps',
                default = False,
                action="store_true",
                dest='show_temps',
                help="Plot local temperature data")
    parser.add_argument('-D', '--debug',
                default=0,
                dest='debug_level',
                help="debug level, 0 (none) to 9 (most)",
                type=int)
    # FIXME, missing -V and --version

    args = parser.parse_args()

    args.period = int( float(args.period) * NTPStats.SecondsInDay)
    if args.endtime is not None:
        args.endtime = iso_to_posix(args.endtime)
    if args.starttime is not None:
        args.starttime = iso_to_posix(args.starttime)

    args.statsdirs = [os.path.expanduser(path)
                     for path in args.statsdirs.split(",")]

    if True == args.show_peer_offsets:
        args.show_peer_offsets = []
    elif 0 < len(args.peer_offsets):
        args.show_peer_offsets = args.peer_offsets.split(",")
    else:
        args.show_peer_offsets = None

    if True == args.show_peer_jitters:
        args.show_peer_jitters = []
    elif 0 < len(args.peer_jitters):
        args.show_peer_jitters = args.peer_jitters.split(",")
    else:
        args.show_peer_jitters = None

    if 0 < args.debug_level:
        sys.stderr.write("ntpviz: INFO: now running at debug: %s\n" % \
            args.debug_level)
        sys.stderr.write("ntpviz: INFO: Parsed Options %s\n" % args)

        if 9 == args.debug_level:
            # crazy debug, also profile
            import cProfile, pstats
            pr = cProfile.Profile()
            pr.enable()

            # register to dump debug on all normal exits
            atexit.register( print_profile )

    nice = 19       # always run nicely
    if 0 != nice:
        try:
            import psutil
            # set ionice() to idle
            p = psutil.Process(os.getpid())
            p.ionice(psutil.IOPRIO_CLASS_IDLE)

        except ImportError:
            if 0 < args.debug_level:
                sys.stderr.write("ntpviz: INFO: psutils not found\n")
            pass

        # set nice()
        nice = os.nice( nice )
        if 2 < args.debug_level:
            sys.stderr.write("ntpviz: INFO: now running at nice: %s\n" % \
                nice)

    for fontpath in ("/usr/share/fonts/liberation",
                     "/usr/share/fonts/liberation-fonts",
                     "/usr/share/fonts/truetype/liberation"):

        if os.path.exists(fontpath):
            os.environ["GDFONTPATH"] = fontpath
            break
    else:
        sys.stderr.write("ntpviz: WARNING: liberation truetype fonts not found\n")
    os.environ["GNUPLOT_DEFAULT_GDFONT"] = "LiberationSans-Regular"

    plot = None

    if 1 == len(args.statsdirs):
        statlist = [NTPViz(statsdir=args.statsdirs[0], sitename=args.sitename,
                        period=args.period, starttime=args.starttime,
                        endtime=args.endtime)]
    else:
        statlist = [NTPViz(statsdir=d, sitename=d,
                        period=args.period, starttime=args.starttime,
                        endtime=args.endtime)
                for d in args.statsdirs]

    if len(statlist) == 1:
        stats = statlist[0]

        if args.show_local_offset or \
           args.show_local_error or \
           args.show_local_jitter or \
           args.show_local_stability or \
           args.show_local_offset_histogram:
            if not len( stats.loopstats ):
                sys.stderr.write("ntpviz: ERROR: missing loopstats data\n")
                raise SystemExit(1)

            if args.show_local_offset:
                plot = stats.local_offset_gnuplot()
            elif args.show_local_error:
                plot = stats.local_error_gnuplot()
            elif args.show_local_jitter:
                plot = stats.local_offset_jitter_gnuplot()
            elif args.show_local_stability:
                plot = stats.local_offset_stability_gnuplot()
            elif args.show_local_offset_histogram:
                plot = stats.local_offset_histogram_gnuplot()

        if None != args.show_peer_offsets or \
           None != args.show_peer_jitters:
            if not len( stats.peerstats ):
                sys.stderr.write("ntpviz: ERROR:  missing peerstats data\n")
                raise SystemExit(1)
            if None != args.show_peer_offsets:
                plot = stats.peer_offsets_gnuplot(args.show_peer_offsets)
            if None != args.show_peer_jitters:
                plot = stats.peer_jitters_gnuplot(args.show_peer_jitters)

        if args.show_temps:
            if not len( stats.temps):
                sys.stderr.write("ntpviz: ERROR: missing temps data\n")
                raise SystemExit(1)
            plot = stats.local_temps_gnuplot()

        if args.show_gps:
            if not len( stats.gpsd):
                sys.stderr.write("ntpviz: ERROR: missing gps data\n")
                raise SystemExit(1)
            plot = stats.local_gps_gnuplot()

    if args.show_local_offset_multiplot:
        plot = local_offset_multiplot(statlist)

    if None != plot:
        # finish up the plot, and exit
        if args.generate:
            gnuplot(plot['plot'])
        else:
            sys.stdout.write(plot['plot'])
        raise SystemExit(0)

    # Fall through to HTML code generation
    if not os.path.isdir(args.outdir):
        try:
            os.mkdir(args.outdir)
        except SystemError:
            sys.stderr.write("ntpviz: ERROR: %s can't be created.\n" \
                 % args.outdir)
            raise SystemExit(1)

    # if no ntpsec favicon.ico, write one.
    ico_filename = os.path.join(args.outdir, "favicon.ico")
    if not os.path.lexists( ico_filename ):
        with open( ico_filename, "w" ) as wp:
            wp.write(binascii.a2b_base64(ntpsec_ico))

    # if no ntpsec logo, write one.
    logo_filename = os.path.join(args.outdir, "ntpsec-logo.png")
    if not os.path.lexists( logo_filename ):
        with open( logo_filename, "w" ) as wp:
            wp.write(binascii.a2b_base64(ntpsec_logo))

    start_time = datetime.datetime.utcnow()
    start_time_str = start_time.strftime("%c")

    title = args.sitename

    index_header = '''\
<!DOCTYPE html>
<html lang="en">
<head>
<link rel="shortcut icon" href="favicon.ico">
<meta charset="UTF-8">
<meta http-equiv="refresh" content="1800">
<meta name="expires" content="0">
<title>%(title)s</title>
<style>
dt {
    font-weight: bold;
    margin-left: 20px;
}
dd {
    margin-top: 4px;
    margin-bottom: 10px;
}
</style>
</head>
<body>
<div style="width:910px">
<a href='https://www.ntpsec.org/'>
<img src="ntpsec-logo.png" alt="NTPsec" style="float:left;margin:5px 50px;">
</a>
<div>
<h1 style="margin-bottom:10px;">%(title)s</h1>
Report generated: %(start_time_str)s UTC <br>
''' % locals()

    # Ugh.  Not clear what to do in the multiplot case
    if len(statlist) == 1:
        index_header += 'Report Period: %1.1f days <br></div> ' \
                 % (float(stats.period) / float(NTPStats.SecondsInDay))
    index_header += '<div style="clear:both;"></div>'

    index_trailer = '''\
<h2>Glossary:</h2>

<dl>
<dt>frequency offset:</dt>
<dd>The difference between the ntpd calculated frequency and the local
system clock frequency (usually in parts per million, ppm)</dd>

<dt>jitter, dispersion:</dt>
<dd>The short term change in a value</dd>

<dt>ms, millisecond:</dt>
<dd>One thousandth of a second = 0.001s</dd>

<dt>mu, mean:</dt>
<dd>The arithmetic mean: the sum of all the values divided by the
number of values.</dd>

<dt>ns, nanosecond:</dt>
<dd>One billionth of a second, also one thousandth of a microsecond,
0.000000001s.</dd>

<dt>percentile:</dt>
<dd>The value below which a given percentage of values fall.</dd>

<dt>ppb, parts per billion:</dt>
<dd>Ratio between two values. These following are all the same:
    1 ppb, one in one billion, 1/1,000,000,000, 0.000,000,001, and
    0.000,000,1%</dd>

<dt>ppm, parts per million:</dt>
<dd>Ratio between two values. These following are all the same:
    1 ppm, one in one million, 1/1,000,000, 0.000,001, and 0.000,1%</dd>

<dt>ppt, parts per thousand:</dt>
<dd>Ratio between two values. These following are all the same:
    1 ppt, one in one thousand, 1/1,000, 0.001, and 0.1%</dd>

<dt>refclock:</dt>
<dd>Reference clock, a local GPS module or other local source of time.</dd>

<dt>remote clock:</dt>
<dd>Any clock reached over the network, LAN or WAN.  Also called a peer
or server.</dd>

<dt>time offset:</dt>
<dd>The difference between the ntpd calculated time and the local system
 clock's time.  (Also can be called phase offset)</dd>

<dt>upstream clock:</dt>
<dd>Any remote clock or reference clock used as a source of time.</dd>

<dt>σ, sigma:</dt>
<dd>Sigma denotes the standard deviation (SD) and is centered on the
arithmetic mean of the data set. The SD is simply the square root of
the variance of the data set.  Two sigma is simply twice the standard
deviation.  Three sigma is three times sigma.  Smaller is better.</dd>

<dt>µs, us, microsecond:</dt>
<dd>One millionth of a second, also one thousandth of a millisecond,
0.000,001s.</dd>
</dl>

<br>
<br>
<br>
<div style="float:left">
This page autogenerated by <a href="https://docs.ntpsec.org/latest/ntpviz.html">
ntpviz</a>, part of the <a href="https://www.ntpsec.org/">NTPsec project</a>
</div>
<div style="float:left;margin-left:350px;">
    <a href="https://validator.w3.org/nu/">
    <img src="https://www.w3.org/html/logo/downloads/HTML5_Logo_32.png"
        alt="html 5">
    </a>
&nbsp;&nbsp;
    <a href="https://jigsaw.w3.org/css-validator/check/referer">
        <img style="border:0;width:88px;height:31px"
            src="https://jigsaw.w3.org/css-validator/images/vcss"
            alt="Valid CSS!" />
    </a>
</div>
<div style="clear:both;"></div>
</div>
</body>
</html>
'''
    imagewrapper = "<img src='%s.png' alt='%s plot'>\n"

    # buffer the index.html output so the index.html is not empty
    # during the run
    index_buffer = index_header
    # if header file, add it to index.html
    header = os.path.join(args.outdir, "header")
    if os.path.isfile(header):
        try:
            header_file = open( header, 'r')
            header_txt = header_file.read()
            index_buffer += '<br>\n' + header_txt + '\n'
        except IOError:
            pass

    if len(statlist) > 1:
        index_buffer += local_offset_multiplot(statlist)
    else:
        imagepairs = [
            ("local-offset", stats.local_offset_gnuplot()),
            # skipa next one, redundant to one above
            #("local-error", stats.local_error_gnuplot()),
            ("local-jitter", stats.local_offset_jitter_gnuplot()),
            ("local-stability", stats.local_offset_stability_gnuplot()),
            ("local-offset-histogram", stats.local_offset_histogram_gnuplot()),
            ("local-temps", stats.local_temps_gnuplot()),
            ("local-gps", stats.local_gps_gnuplot()),
            ("peer-offsets", stats.peer_offsets_gnuplot()),
        ]

        peerlist = list(stats.peersplit().keys())
        # sort for output order stability
        peerlist = sorted( peerlist )
        for key in peerlist:
            imagepairs.append(("peer-offset-" + key,
                           stats.peer_offsets_gnuplot([key])))
        imagepairs.append(("peer-jitters",
                           stats.peer_jitters_gnuplot()))
        for key in peerlist:
            plot = stats.peer_jitters_gnuplot([key])
            if len( plot ):
                imagepairs.append(("peer-jitter-" + key, plot))

        percs = []
        for (imagename, image) in imagepairs:
            if not image:
                continue
            percs.append( image['percs'] )
            index_buffer += "<div>\n<h2>%s:</h2>\n" % image['title']
            div_name = imagename.replace('-', ' ')
            index_buffer += imagewrapper % \
                             (imagename.replace(':', '%3A'), div_name)
            if image['html']:
                index_buffer += "<div>\n%s</div>\n" % image['html']
            if 'peer-jitter-' == imagename[:12]:
                exp = 'peer-jitter'
            elif 'peer-offset-' == imagename[:12]:
                exp = 'peer-offset'
            else:
                exp = imagename
            index_buffer += "<br><br>\n"
            gnuplot(image['plot'], os.path.join(args.outdir, imagename + ".png"))
            index_buffer += "</div>\n"

    # dump percs
    if false:
        index_buffer += "<div>\n"
        index_buffer += str( percs )
        index_buffer += "</div>\n"

    # if footer file, add it to index.html
    footer = os.path.join(args.outdir, "footer")
    if os.path.isfile(footer):
        try:
            footer_file = open( footer, 'r')
            footer_txt = footer_file.read()
            index_buffer += '<br>\n' + footer_txt + '\n'
        except IOError:
            pass
    index_buffer += index_trailer

    # and send the file buffer
    with open(os.path.join(args.outdir, "index.html"), "w") as ifile:
        ifile.write(index_buffer)
        ifile.close()

# end
