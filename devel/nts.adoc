= NTS support specification =

== Cisco's Statement of Work requirements ==

The NTS implementation shall:

* Use OpenSSL 1.1.1 for its crypto functions.

* Address RFC5705 Keying Material Exporting and AES_SIV (RFC5297) code
  support which may not be natively supported in OpenSSL.

* Comply with the standardized specification of NTS
  https://tools.ietf.org/html/draft-ietf-ntp-using-nts-for-ntp

* Be interoperable with the other reference implementations in IETF hackathons.

== General Ideas ==

The NTP server maintains no per-client state.  The NTP client
stores the state in a cookie which is sent with each request.
The cookie is provided by the NTS-KE server.  The NTP server will
decrypt it to recover the session keys.

NTS should avoid exposing information that would be useful in
tracking the client.  (Consider a laptop that moves from home
to work to a coffee shop.)  Thus cookies should only used once.
To implement that, each NTP response includes a new encrypted cookie.

NTS should not assist DDoS amplification.  All NTP responses
are the same length as the request.  This means that some
fields are padded to match the length of the response that
will replace them.

== System Partitioning ==

This picture is for discussion.  In actual packaging Alpha and Bravo
will both be inside ntpd. Charlie and Delta, on the other hand, need
to be separate because Delta will have its own public port serving
requests from Bravo.Also, potentially, one Delta (or Delta/Echo
combination) could serve multiple Charlies, e.g. in a data-center
deployment.

[ditaa, "NTS-flow", "svg"]
----
  + - - - - - - - - +
  ;     Client      ;
  ; +-------------+ ;           +-------------+
  ; |Bravo        | ;           |Delta        |
  ; |NTS-KE client|-^---------->|NTS-KE server|
  ; +-------------+ ;           +-------------+
  ;     ^           ;                |
  ;     |           ;              .----.
  ;     |           ;              |Echo|
  ;     |           ;              .----.
  ;     |           ;                |
  ; +-----------+   ;           +-----------+
  ; |Alpha      |   ;           |Charlie    |
  ; |NTP client |---^---------->|NTP server |
  ; +-----------+   ;           +-----------+
  + - - - - - - - - +
----

In this diagram, an arrow means "initiates requests to". 
Responses flow in the other direction.  Each connection
is used for one request/response transaction.


=== Alpha -> Bravo ===
NTP-client to NTS-KE-client (Alpha to Bravo) is pretty simple.

  NTS-KE-client sends:
    Host name of NTS-KE server
    Optional preferred IP Address 4.1.7
    A sorted list of AEAD algorithms 4.1.5
  It gets back:
    IP Address 4.1.7
    1 to 8 cookies  4.1.6
    C2S and S2C encryption keys  4.2, 5.1
    The selected AEAD algorithm 4.1.5

For AEAD, we need libaes_siv.so, RFC 5297
It's available, but not in OpenSSL yet

=== Bravo -> Delta ===
NTS-client-NTS-server (Bravo to Delta) is mostly the above in TLS over TCP.
NTS-client has to make the C2S and S2C keys.  They are tangled up
with TLS.

=== Echo -> Charlie & Delta ===
In this mode, the NTS server generates the cookies, and thus
must know the master key and the cookie generation recipe.

Echo to the servers Charlie and Delta is a one shot.
Echo sends a seed/ratchet mechanism number pair to both servers.
optionally a rotation time and cookie format number could be sent.

=== Or... dump the Echo box
In this mode, the NTS-server doesn't know the master key
or the cookie format.

NTS-server to NTP-server
  NTS-Server sends:
    C2S and S2C encryption keys  4.2, 5.1
    A sorted list of AEAD algorithms  4.1.5
  It gets back:
    The selected AEAD algorithm 4.1.5
    1 to 8 cookies  4.1.6

=== Alpha -> Charlie ===
NTP-client to NTP-server (Alpha to Charlie)

If all goes well (no lost packets) the client sends:

  The normal 48 byte NTP packet
  A 32 byte unique ID 5.3
  A cookie 5.4
  Authentication using C2S 5.6
  
It gets back the same, with the cookie replaced with a new cookie
and S2C used for authentication.
New cookies are encrypted with S2C.  Pg 20
The response is the same lengh.  The cookie is moved from
unencrypted to encrypted.

All the extra data is in real NTP extensions.  (No more of
the magic length kludgery for the current shared key authentication.)

If packets (and hence cookies) are lost, the client will include
a cookie-placeholder for each extra cookie it wants.  5.5
Those slots will be returned with new cookies.

The AEAD algorithm is setup to encrypt some data as well as authenticate.
For the request, that's empty.  For the response, it contains a new
cookie.  (Or cookies.)
I think we need a nonce in there.

== Key Generation and Usage ==

NTS makes use of three keys:

* Client to Server (c2s)

* Server to Client (s2c)

* NTS Master Key

Because one of the goals of NTS is to not require any per-client state in
the servers, the server (both NTPD and NTS-KE) does not possess either of the
c2s/s2c pair. Both servers possess the NTS Master Key, which is expected to
be updated somewhat regularly.

The c2s/s2c pair is created during the TLS handshake between client and NTS-KE.
As part of this NTS-KE will create a variable number of cookies (should be 8).
These cookies are encrypted with the NTS master key, and are opaque to the
client. The cookies contain the c2s/s2c pair in a form that NTPD will
understand, and is how NTPD is able to en/decrypt data without needing to
store per-client keys.

When sending an NTS packet the client attaches a cookie-blob in cleartext,
then encrypts the rest of the data using the c2s key. When the NTPD server
receives the packet it decrypts the cookie-blob using its Master Key, and
extracts the c2s/s2c pair so it can decrypt the rest. The response packet
is encrypted using the s2c key extracted from the cookie.

== Odds and ends ==

How many cookies should the NTP client try to hold?  8

There is no hard reason, but it is what the server SHOULD return.  4.1.6
It also matches the number of samples that ntpd remembers (the reach bit
mask in ntpq/peers) and running out of responses is a good time to do
special things like get a new pool server or get new cookies by running
NTS-KE again.

---

We need an exponential backoff when the NTS-KE step fails.

---

Note that the communication between NTS-KE client and NTP client
needs to be kept private.  (aka encrypted if it goes over the net)
Same for NTS-KE server and NTP server.
Both connections contain C2S and S2C keys.

