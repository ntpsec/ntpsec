= NTS support specification

== Cisco's Statement of Work requirements

The NTS implementation shall:

* Use OpenSSL 1.1.1 for its crypto functions.

* Address RFC5705 Keying Material Exporting and AES_SIV (RFC5297) code
  support which may not be natively supported in OpenSSL.

* Comply with the standardized specification of
  link:https://tools.ietf.org/html/draft-ietf-ntp-using-nts-for-ntp[NTS]

* Be interoperable with the other reference implementations in IETF hackathons.

== General Ideas

The NTP server maintains no per-client state.  The necessary state
is provided by a cookie that is included with each NTP request.  An
initial batch of cookies is provided by the NTS-KE server.  The
NTP client treats the cookies as opaque data and sends one to the
NTP server with each request.

A cookie contains the AEAD algorithm and keys necessary to
authenticate a request.  They are encrypted with the NTP servers
key.  The NTP server decrypts the cookie to retrieve the
encryption parameters (AEAD algorithm and keys) and then uses
them to authenticate the packet.  To issue a new cookie, the NTP
server makes a new nonce and uses the AEAD algorithm and keys
from the old cookie.

NTS should avoid exposing information that would be useful in
tracking the client.  (Consider a laptop that moves from home
to work to a coffee shop.)  Thus cookies should only be used once.
To implement that, each NTP response includes a new cookie, which is
encrypted when sent to the client.  (Otherwise, the cookie could be
observed in transit, which would allow for tracking the client when
it later echoes that cookie back to the server.)

NTS should not assist DDoS amplification.  All NTP responses
are the same length as the request.  This means that some
fields are padded to match the length of the response that
will replace them.

== System Partitioning

This picture is for discussion.  In actual packaging Alpha and Bravo
will both be inside ntpd. In the simple case, Charlie and Delta can
also be packaged together.  In complicated cases, Delta could serve multiple
Charlies, e.g. in a data-center deployment or for load sharing.

[ditaa, "NTS-flow", "svg"]
----
  /-------------------\
  |     Client        |
  | /---------------\ |           /---------------\
  | | Bravo         | |           | Delta         |
  | | NTS KE client +------------>| NTS KE server |<-\
  | \---------------/ |           \-----+---------/  |
  |     ^             |                 |            |
  |     |             |                 |       /----+------\
  :     |             :                 |       | Admin Key |
  |     |             |                 |       \----+------/
  |     |             |                 v            |
  | /---+--------\    |           /-------------\    |
  | | Alpha      |    |           | Charlie     |<---/
  | | NTP client +--------------->| NTP server  |
  | \------------/    |           \-------------/
  \-------------------/
----

In this diagram, an arrow means "initiates requests to".
Responses flow in the other direction.  Each connection
is used for one request/response transaction.


The NTS-KE server has to make cookies that the NTP server
will process.  There are 2 ways to do that.  First, they can share
the same key, new-cookie recipe, and new-key recipe.  If they are
in separate systems, the admin must set up the initial key and keep
the keys in sync if either system gets trashed.  The second way is
for the NTS-KE server to ask the NTP server for new cookies.  If it
does that, it doesn't need to know the key or anything about the
contents of a cookie.


=== Alpha -> Bravo
NTP client to NTS-KE client (Alpha to Bravo) is pretty simple.
As these will both be inside ntpd, this will be function calls,
not a network connection.

====  NTS-KE client sends:
-    Hostname of NTS-KE server
-    Optional preferred NTPD server hostname or IP Address
     link:https://tools.ietf.org/html/draft-ietf-ntp-using-nts-for-ntp#section-4.1.7[4.1.7]
-    A sorted list of AEAD algorithms
     link:https://tools.ietf.org/html/draft-ietf-ntp-using-nts-for-ntp#section-4.1.5[4.1.5]

====  NTS-KE server and NTS-KE client compute from the TLS connection:
-    C2S and S2C encryption keys
     link:https://tools.ietf.org/html/draft-ietf-ntp-using-nts-for-ntp#section-4.2[4.2],
     link:https://tools.ietf.org/html/draft-ietf-ntp-using-nts-for-ntp#section-5.1[5.1]

====  NTS-KE client gets back:
-    NTPD server hostname or IP Address
     link:https://tools.ietf.org/html/draft-ietf-ntp-using-nts-for-ntp#section-4.1.7[4.1.7]
-    1 to 8 cookies
     link:https://tools.ietf.org/html/draft-ietf-ntp-using-nts-for-ntp#section-4.1.6[4.1.6]
-    The selected AEAD algorithm
     link:https://tools.ietf.org/html/draft-ietf-ntp-using-nts-for-ntp#section-4.1.5[4.1.5]

For AEAD, we need libaes_siv.so, RFC 5297
It's not in OpenSSL yet.
  https://github.com/dfoxfranke/libaes_siv

An NTP client SHOULD NOT initiate NTS-KE by default.  Configuration
parameters from the NTPD config file will tell the NTPD client when and
how to initiate NTS-KE.

While it is technically permitted (see RFC5280, page 35) to put an IP
address in a subjectAltName in a certificate, this is essentially never
done in practice, and rarely with public CAs.  Accordingly, the NTS-KE
client SHOULD NOT generally initiate NTS for servers specified by IP
address (whether IPv4 or IPv6).  The NTS-KE client MAY initiate NTS
for servers specified by IP address (whether IPv4 or IPv6) for testing
purposes.

Additionally, the NTP client SHOULD NOT initiate NTS for pool
associations by default.  The most common pool is the public pool at
pool.ntp.org.  The volunteer NTP servers will never be able to pass a
certificate check for <anything>.pool.ntp.org, so NTS-KE will always
fail, and represents a useless load on the public pool servers.  As the
pool statement can be used in other configurations that could work
with NTS-KE, the NTP client SHOULD allow NTS to be enabled on pool
associations.

The NTS-KE client SHOULD provide a configuration parameter to
configure the root CAs used to validate TLS certificates.

The NTS-KE client SHOULD have a configuration parameter to specify
which TLS protocols are permissible.  Regardless of what is
configured, because the NTS specification relies on RFC 5705, and
also because it explicitly says so, TLS 1.3 is the minimum TLS
version allowed.

The NTS-KE client SHOULD provide a configuration parameter to
configure an OpenSSL cipher string for the TLS connection.

The NTS-KE client SHOULD provide a configuration parameter to
configure an OpenSSL cipher string for the AEAD algorithms.

The NTP client SHOULD provide a mechanism for the administrator to
see whether NTS is currently in use on a given server association.

=== Bravo -> Delta
The NTS-KE client to NTS-KE server (Bravo to Delta) communication is
mostly the above in TLS 1.3 (or later) over TCP in the format
specified in the NTS draft.

The NTS-KE client (Bravo) and NTS-KE server (Delta) independently
derive the C2S and S2C keys.  For OpenSSL, this is implemented by
making two calls to SSL_export_keying_material(), which implements
RFC5705.  The label and context inputs are provided in
link:https://tools.ietf.org/html/draft-ietf-ntp-using-nts-for-ntp#section-5.1[5.1].
This process is deterministic, so both ends generate the same C2S and S2C.

The NTS-KE client passes C2S and S2C to the NTP client.  The NTS-KE
server uses them to make the initial cookies.

The NTS-KE server then generates and returns 8 cookies using, for
example, the suggested format in section 6 of the NTS draft.  To do
so, the NTS-KE server needs a master key, called "K" in the draft.

=== Alpha -> Charlie
NTP client to NTP server (Alpha to Charlie)

If all goes well (no lost packets) the client sends:

-  The normal 48 byte NTP packet
-  A 32+ byte unique ID
link:https://tools.ietf.org/html/draft-ietf-ntp-using-nts-for-ntp#section-5.3[5.3]
-  A cookie
link:https://tools.ietf.org/html/draft-ietf-ntp-using-nts-for-ntp#section-5.4[5.4]
-  Authentication using C2S
link:https://tools.ietf.org/html/draft-ietf-ntp-using-nts-for-ntp#section-5.6[5.6]

It gets back the same, with the cookie replaced with a new cookie
and S2C used for authentication and to encrypt the new cookie.

The response is the same length.

All the extra data is in real NTP extensions.  (No more of
the magic length kludgery for the current shared key authentication.)

If packets (and hence cookies) are lost, the client will include
a cookie-placeholder for each extra cookie it wants.
link:https://tools.ietf.org/html/draft-ietf-ntp-using-nts-for-ntp#section-5.5[5.5]
Those slots will be returned with new cookies.

The AEAD algorithm used for authentication is set up to encrypt some
data as well.  For the request, the encrypted data is empty.  For the
response, it contains a new cookie (or cookies). AEAD also needs a nonce.


== Configuration

The NTS-KE server SHOULD have a configuration parameter to specify
which TLS protocols are permissible.  Regardless of what is
configured, because the NTS specification relies on RFC 5705, and
also because it explicitly says so, TLS 1.3 is the minimum TLS
version allowed.

The NTS-KE server SHOULD have a configuration parameter to specify its
preferred AEAD algorithms for the TLS connection in preference order.
This SHOULD be provided as an OpenSSL cipher string.

The NTS-KE server SHOULD have a configuration parameter to specify
its preferred AEAD algorithms for the NTPD connection in preference
order.  This SHOULD be provided as an OpenSSL cipher string.
AEAD_AES_SIV_CMAC_256 [RFC5297] must be supported[4.1.5]

Honoring the NTS-KE client's AEAD preference order for the NTPD
connection is OPTIONAL[4.1.5].  How we reconcile the NTS-KE client
and NTS-KE server preference order is TBD.

The NTS-KE server SHOULD have a configuration parameter to specify
the TLS key, certificate, and intermediate certificate bundles.

The NTS-KE server MAY have a method to reload the key, certificate,
and intermediate certificate bundles without a full daemon restart.

== NTS Configuration parameters (client side)

Options now implemented in the config parser are now described in
docs/includes/auth-commands.txt

To avoid having to hand-configure TLS versions, the right (and
conformant) thing is to do is honor the global mintls and maxtls
options, then just use the most recent version at or above it your TLS
library and the remote both support. If the remote can't cope, you
abort.

To avoid having to hand-configure ciphers offered to the remote, we
can initially have a list of common known-good ones wired in.
Eventually, look into how openssl-ciphers does this and autoconfigure.

== NTS-KE Server Configuration parameters

== TLS Options

The directory with the Certificates of Certification Authorities (CAs).

....
TLSCACertificatePath directory-path
....

A file with this NTS-KE servers certificate data in PEM format.  May
include chain certificates.

....
TLSCertificateFile file-path
....

The PEM-encoded private key file for the server.

....
TLSCertificateKeyFile file-path
....

A colon-separated cipher-spec string consisting of OpenSSL cipher
specifications to configure the Cipher Suite the client is permitted
to negotiate in the TLS handshake phase.  TLS1.2 and TLS1.3 must be
specified separately.

....
TLSCipherSuite TLS1.2 cipher-spec
TLSCipherSuite TLS1.3 cipher-spec
....

A colon-separated cipher-spec string consisting of OpenSSL AEAD cipher
specifications to configure the Cipher Suite for the NTS cookie.  TLS1.2
and TLS1.3 must be specified separately. AEAD_AES_SIV_CMAC_256 is
mandatory, and need not be specified.

....
NTPCipherSuite TLS1.2 cipher-spec
NTPCipherSuite TLS1.3 cipher-spec
....

Option to prefer the server's cipher preference order for the TLS connection.
Default on.

....
TLSHonorCipherOrder on|off
....

Option to prefer the server's cipher preference order for the cookie.
Default on.

....
NTPHonorCipherOrder on|off
....

Which versions of the TLS protocol will be accepted in new TLS connections.

....
TLSProtocol [+TLS1.2] [+TLS1.3]
....

Configures one or more sources for seeding the Pseudo Random Number
Generator (PRNG) in OpenSSL at startup time.  One source per directive.
Multiple directives may be used.  Source may be: builtin, "file:/dev/random",
"file:/dev/urandom", etc.

....
TLSRandomSeed source [bytes]
....

Sets the Certificate verification level for the Client Authentication.
The level may be: none: no client Certificate is required at all, optional:
the client may present a valid Certificate, require: the client has to
present a valid Certificate, optional_no_ca: the client may present a
valid Certificate but it need not be verifiable.

....
TLSVerifyClient level
....


== Key Generation and Usage

NTS makes use of three keys:

* Client to Server key (C2S)

* Server to Client key (S2C)

* NTS Master Key (called K in the NTS draft)

Because one of the goals of NTS is to not require any per-client
state in the servers, the servers (both NTP and NTS-KE) do not
store either of C2S/S2C.  Both servers possess the NTS Master Key,
which is expected to be updated somewhat regularly, with old versions
being kept for some time (SHOULD be two rotation cycles) to allow for
old cookies to be decrypted.

The C2S and S2C keys are derived from the TLS session data between
the NTS-KE client and the NTS-KE server using the RFC5705 algorithm.
These are not the same as the keys used by TLS to protect the data
flowing over the TLS connection itself.

As part of the setup, NTS-KE will create a variable number of cookies
(which SHOULD be 8).  These cookies are encrypted with the NTS Master
Key, and are opaque to the client. The cookies contain C2S and S2C in
a form that the NTP server will understand, and this is how the NTP
server is able to en/decrypt data without needing to store per-client
keys.

When sending an NTP packet, the client attaches a cookie blob in
cleartext, then authenticates the packet using the C2S key. When
the NTP server receives the packet, it decrypts the cookie using its
NTS Master Key to recover C2S and S2C.  It uses C2S to authenticate the
packet. For the response, S2C is used to encrypt the new cookies and
authenticate the return packet.

== Odds and ends

How many cookies should the NTP client try to hold?  8

There is no hard reason, but it is what the NTS-KE server SHOULD return.
link:https://tools.ietf.org/html/draft-ietf-ntp-using-nts-for-ntp#section-4.1.6[4.1.6]
It also matches the number of samples that ntpd remembers (the reach bit
mask in ntpq/peers) and running out of responses is a good time to do
special things like getting a new pool server or getting new cookies by running
NTS-KE again.

---

We need an exponential backoff when the NTS-KE step fails.

---

Note that the communication between NTS-KE client and NTP client
needs to be kept private.  (aka encrypted if it goes over the net)
Same for NTS-KE server and NTP server.
Both connections contain C2S and S2C keys.

== Potential cookie recipe(s)

. Form a plaintext "P" comprised of records
.. minimum of an AEAD algorithm record, c2s, and s2c key records
.. (optional) previously connected network address (for academic purposes)
.. (optional) a timestamp when to stop honoring the current cookie series
.. (optional) a timestamp when the current cookie series began (for expiration)
.. (optional) a Modified Julian Date when to stop honoring the current cookie series
.. (optional) a MJD when the current cookie series began (for expiration)
.. (optional) a number of cookies remaining before series expiration.
.. (optional) the number of cookies (estimated) since series began for expiration.
. encrypt it with the master key "K" (which has nothing to do w/ TLS)
. form the cookie w/ records for the master key number "I", an unsized nonce "N", and the ciphertext "C".

----
base	29	NThkZGExNTYxZGY3YWQzMTkxOGI4OTQ0ZWQ5YTU3MTc=	ZGZmZTg0MTBhZjk2YTgxOGE2ZDMwOGQ0Nzg0ZGMxNzg
track	192.168.1.107
btai	3753708891
etai	3761747291
bmjd	58460
emjd	58557
cdown	3460
cup	4210
----

An overly complicated example plaintext. records are carriage return terminated and fields are horizontal tab separated.
The example is set in January of 2019 for a chain starting mid-December and ending mid-March.
It is likely that only one of the expiry fields is desirable.
The cookie count up/down counter should change by the number of cookies issued (8).
The c2s/s2c fields should be base64 encoded.

----
27391	MjI4MGVlYWY2ZWMzOGZjNmQ4MmFjMjhmMGViYzYxZTQ=	U2FsdGVkX1/dO8WX4e+daOzR2dcRvbHOUv3jAMT51NttWrK+CnBUDWuhm54Hz31TG1P+VkWlrMGHAIHea9gQ3+shZj+I8pdPLrEn9V/E+1VJMC96qBo+x55yQmOyRLEJJSJMs25dSQ0idndKAOYqUOyulwruTe7QuPr+L5fVB9qSw2n18w/6BtnXsivAEjMpfxP9X7ZDZ46LHm1ayAcmMoccdjuwKqgPaa2ez33rlruXmcsF5omlguBZWxjm/iNZ
----

A wholly made up example cookie.

== Unresolved issues for the next RFC WG

How to make NTS-KE work, securely, with pooled servers?

The binary KE request-response format is unfortunate for all the usual
reasons (endianness issues etc). At the expected transaction volume,
the encode/decode overhead shouldn't be an issue.

link:https://tools.ietf.org/html/draft-ietf-ntp-using-nts-for-ntp#section-4.1.3[4.1.3], link:https://tools.ietf.org/html/draft-ietf-ntp-using-nts-for-ntp#section-4.1.4[4.1.4]

Is the response in case of abuse 'continue the abuse, just wait a minute'?

link:https://tools.ietf.org/html/draft-ietf-ntp-using-nts-for-ntp#section-5.7[5.7]

Does the unique identifier extension need to be omniversally unique?

Why are the timestamps, unique identifier extension etc. seemingly not tamper resisted?

Can NTSN and other KODs get signed?

== NTS/mode 7 next

=== NTS and mode 6 and 7

Network Time Security explicitly only supports modes 3 and 4 at this time.
I see no reason why NTS could not be expanded to cover modes 1, 2, 6, and 7.
Expansion to cover modes 6&7 should require an authentication token extension.

=== mode 6 -> mode 7 next

I feel that in keeping with comments. It should be possible to shift a
copy of mode 6 to UTF-8 JSON-RPC and rebadge it as a new mode 7.  The
following is an overly verbose partial mockup of a transaction chain
querying peer-stats.  All the numbers should be in _decimal_ without
the hexadecimal timestamps and such.

[source, json]
----
{
   "jsonrpc" : "2.0",
   "id" : 1,
   "params" : {},
   "method" : "readstat"
}
{
   "jsonrpc" : "2.0",
   "id" : 1,
   "result" : {
      "answer" : {
         "associations" : [
            62414,
            62413,
            62408,
            62407,
            62406,
            62405,
            62402,
            62401,
            62400,
            62399,
            62398
         ]
      }
   }
}

{
   "jsonrpc" : "2.0",
   "id" : 2,
   "params" : {
      "association" : 62398
   },
   "method" : "readvar"
}
{
   "jsonrpc" : "2.0",
   "id" : 2,
   "result" : {
      "answer" : {
         "hmode" : 3,
         "filtdisp" : [
            14.68,
            1.5,
            2.36,
            3.45,
            4.75,
            5.19,
            6.19,
            7.12
         ],
         "keyid" : 0,
         "dstadr" : "127.0.0.1",
         "jitter" : 2.792031,
         "dstport" : 123,
         "rootdelay" : 0,
         "dispersion" : 8.528601,
         "flash" : 0,
         "filtoffset" : [
            -829.24,
            -831.68,
            -833.19,
            -832.72,
            -832.48,
            -831.32,
            -831.14,
            -830.83
         ],
         "reach" : 255,
         "mode" : 2,
         "rootdisp" : 0,
         "ppoll" : 6,
         "reftime" : 3757323811.47605,
         "delay" : 0,
         "offset" : -829.240892,
         "pmode" : 4,
         "srcadr" : "127.127.46.0",
         "precision" : -8,
         "headway" : 0,
         "hpoll" : 6,
         "rec" : 3757323811.5776,
         "xmt" : 3757323811.57759,
         "stratum" : 0,
         "srchost" : "GPSD(0)",
         "unreach" : 0,
         "srcport" : 123,
         "leap" : 0,
         "refid" : "GPSD",
         "filtdelay" : [
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
         ]
      },
      "association" : 62398
   }
}


...
----

== Unresolved issues for the next RFC revision

The binary KE request-response format is unfortunate for all the usual
reasons (endianness issues etc). At the expected transaction volume,
the encode/decode overhead shouldn't be an issue.

== Martin Langer's notes == 

um... maybe the first hint... The current OpenSSL version doesn't
work with NTS and TLS1.3. The TLS key exporter function fails
because the exporter label is too long. It's an OpenSSL bug which is
already committed and fixed. The next OpenSSL version 1.1.1b should
work again.

This is my current workaround:

--
// TODO: bug in OpenSSL 1.1.1a --> "EXPORTER-network-time-security/1"
// doesn't work.
#define *TLS_Exporter_Labe**l* **"EXPORTER-nts/1"
--

// end
